Efficient Maintenance of Leiden Communities in Large Dynamic
Graphs
Yumao Xie
The Chinese University of Hong
Kong, Shenzhen
Shenzhen, China
yumaoxie@link.cuhk.edu.cn

Chunxu Lin
The Chinese University of Hong
Kong, Shenzhen
Shenzhen, China
chunxulin1@link.cuhk.edu.cn

Yixiang Fang
The Chinese University of Hong
Kong, Shenzhen
Shenzhen, China
fangyixiang@cuhk.edu.cn

Yongmin Hu
ByteDancen
Hangzhou, China
huyongmin@bytedance.com

Yingqian Hu
ByteDance
Hangzhou, China
huyingqian@bytedance.com

Chen Cheng
ByteDance
Singapore, Singapore
chencheng.sg@bytedance.com

Abstract
As a well-known community detection algorithm, Leiden has been
widely used in various scenarios such as large language model
(LLM) generation, anomaly detection, and biological analysis. In
these scenarios, the graphs are often large and dynamic, where
vertices and edges are inserted and deleted frequently, so it is costly
to obtain the updated communities by Leiden from scratch when
the graph has changed. Recently, one work has attempted to study
how to maintain Leiden communities in the dynamic graph, but
it lacks a detailed theoretical analysis, and its algorithms are in-
efficient for large graphs. To address these issues, in this paper,
we first theoretically show that the existing algorithms are rela-
tively unbounded via the boundedness analysis (a powerful tool for
analyzing incremental algorithms on dynamic graphs), and also an-
alyze the memberships of vertices in communities when the graph
changes. Based on theoretical analysis, we develop a novel efficient
maintenance algorithm, called Hierarchical Incremental Tree Lei-
den (HIT-Leiden), which effectively reduces the range of affected
vertices by maintaining the connected components and hierarchi-
cal community structures. Comprehensive experiments in various
datasets demonstrate the superior performance of HIT-Leiden. In
particular, it achieves speedups of up to five orders of magnitude
over existing methods.

CCS Concepts
â€¢ Information systems â†’ Clustering; Data stream mining; â€¢
Theory of computation â†’ Dynamic graph algorithms.

Keywords
Incremental graph algorithms, community detection, Leiden algo-
rithm

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
SIGMOD â€™26, Bengaluru, India
Â© 2026 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-XXXX-X/2018/06
https://doi.org/XXXXXXX.XXXXXXX

ACM Reference Format:
Chunxu Lin, Yumao Xie, Yixiang Fang, Yongmin Hu, Yingqian Hu, and Chen
Cheng. 2026. Efficient Maintenance of Leiden Communities in Large Dy-
namic Graphs. In Proceedings of Make sure to enter the correct conference
title from your rights confirmation email (SIGMOD â€™26). ACM, New York, NY,
USA, 18 pages. https://doi.org/XXXXXXX.XXXXXXX

1 Introduction

(a) A static graph ğº

(b) A dynamic graph ğº â€²

Figure 1: Illustrating community maintenance, where (ğ‘£1, ğ‘£3)
is a newly inserted edge and (ğ‘£3, ğ‘£5) is a newly deleted edge.
As one of the fundamental measures in network science, modu-
larity [60] effectively measures the strength of division of a network
into modules (also called communities). Essentially, it captures the
difference between the actual number of edges within a community
and the expected number of such edges if connections were random.
By maximizing the modularity of a graph, it can reveal all the com-
munities in the graph. In Figure 1(a), for example, by maximizing
the modularity of the graph, we can obtain two communities ğ¶1 and
ğ¶2. As shown in the literature [13, 78], the graph communities have
found a wide range of applications in recommendation systems,
social marketing, and biological analysis.

One of the most popular community detection (CD) algorithms
that use modularity maximization is Louvain [10], which partitions
a graph into disjoint communities. As shown in Figure 2(a), Louvain
employs an iterative process with each iteration having two phases,
called movement and aggregation, to adjust the community struc-
ture and improve modularity. Specifically, in the movement phase,
each vertex is relocated to a suitable community to maximize the
modularity of the graph. In the aggregation phase, all the vertices
belonging to the same community are merged into a supervertex to
form a supergraph for the next iteration. Since a supervertex corre-
sponds to a set of vertices, the communities of a graph naturally
form a tree-like hierarchical structure. In practice, to balance mod-
ularity gains against the running time, users often limit Louvain to
ğ‘ƒ iterations, where ğ‘ƒ is a pre-defined parameter.

ğ‘£!ğ‘£"ğ¶#ğ‘£$ğ‘£%ğ‘£#ğ‘£&ğ‘£'ğ‘£(ğ¶&ğ‘£!ğ‘£"ğ¶#ğ‘£$ğ‘£%ğ‘£#ğ‘£&ğ‘£'ğ‘£(ğ¶&SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

(a) The process of the Louvain algorithm [10].

(a) The process of the increment algorithms in [70].

(b) The process of the Leiden algorithm [80].
Figure 2: Illustrating the Louvain and Leiden algorithms.

Despite its popularity, Louvain may produce communities that
are internally disconnected. This typically occurs during the move-
ment phase, where a vertex that serves as a bridge within a com-
munity may be moved to a different community that has stronger
connections, thereby breaking the connectivity of the original com-
munity. To overcome this issue, Traag et al. [80] proposed the Leiden
algorithm 1, which introduces an additional phase, called refine-
ment, between the movement and aggregation phases, as shown
in Figure 2(b). Specifically, during the refinement phase, vertices
explore merging with their neighbors within the same community
to form sub-communities. By adding this additional phase, Leiden
produces communities with higher quality than Louvain, since its
communities well preserve the connectivity.

As shown in the literature, Leiden has recently received plenty of
attention because of its applications in many areas, including large
language model (LLM) generation [43, 54, 55, 63, 104], anomaly
detection [27, 38, 65, 73, 82], and biological analysis [1, 8, 28, 47, 99].
For example, Microsoft has recently developed Graph-RAG [54],
a retrieval-augmented generation (RAG) method that enhances
prompts by searching external knowledge to improve the accuracy
and trustworthiness of LLM generation, and builds a hierarchical
index by using the communities detected by Leiden. As another
example, Liu et al. introduced eRiskComm [48], a community-based
fraud detection system that assists regulators in identifying high-
risk individuals from social networks by using Louvain to partition
communities, and Leiden can be naturally applied in this context.
In the aforementioned application scenarios, the graphs often
evolve frequently over time, with many insertions and deletions
of vertices and edges. For instance, in Wikipedia, the number of
English articles increases by about 15,000 per month as of July
20242, making their contributors form a massive and continuously
evolving collaboration graph, where nodes represent users. In these
settings, changes to the underlying graph can significantly alter the
communities produced by Leiden, thereby affecting downstream
tasks and decision-making. However, the original Leiden algorithm
is designed for static graphs, so it is very costly to recompute the
communities from scratch using Leiden whenever a graph change
occurs, especially for large graphs. Hence, it is strongly desirable to
develop efficient algorithms for maintaining the up-to-date Leiden
communities in large dynamic graphs.

Prior works. To maintain Louvain communities in dynamic
graphs, several algorithms have been developed, such as DF-Louvain
[69], Delta-Screening [97], DynaMo [105], and Batch [18]. However,
little attention has been paid to maintaining Leiden communities. To
the best of our knowledge, [70] is the only work that achieves this.
It first uses some optimizations for the first iteration of DF-Leiden,

1As of July 2025, Leiden has received over 5,000 citations according to Google Scholar.
2https://en.wikipedia.org/wiki/Wikipedia:Size_of_Wikipedia

(b) The process of our HIT-Leiden algorithm.
Figure 3: Algorithms for maintaining Leiden communities.

and then invokes the original Leiden algorithm for the remaining
iterations, as depicted in Figure 3(a). Following the optimized move-
ment phase (opt-movement), the refinement phase in DF-Leiden
separates communities affected by edge or vertex changes into mul-
tiple sub-communities, while leaving unchanged communities as
single sub-communities. The aggregation phase remains identical
to that of the Leiden algorithm. After constructing the aggregated
graph, the standard Leiden algorithm is applied to complete the
remaining CD process. The author has also developed two variants
of DF-Leiden, called ND-Leiden and DS-Leiden, by using differ-
ent optimizations for the movement phase of the first iteration.
Nevertheless, there is a lack of detailed theoretical analysis for
these algorithms, and they are inefficient for large graphs with few
changes.

Our contributions. To address the above limitations, we first
theoretically analyze the time cost of existing algorithms for main-
taining Leiden communities and theoretically show that they are
relatively unbounded via the boundedness analysis, which is a
powerful tool for analyzing the time complexity of incremental
algorithms on dynamic graphs. We further analyze the membership
of vertices in communities and sub-communities when the graph
edges change, and observe that the procedure for maintaining these
memberships generalizes naturally to all the supergraphs generated
by Leiden. The above analysis not only lays a solid foundation for us
to comprehend existing algorithms but also offers us opportunities
to improve upon them.

Based on the above analyses, we develop a novel efficient mainte-
nance algorithm, called Hierarchical Incremental Tree Leiden (HIT-
Leiden), which effectively reduces the range of affected vertices by
maintaining the connected components and hierarchical commu-
nity structures. As depicted in Figure 3(b), HIT-Leiden is an itera-
tive algorithm with each iteration having three key phases, namely
incremental movement, incremental refinement, and incremental
aggregation, abbreviated as inc-movement, inc-refinement, and
inc-aggregation, respectively. More specifically, inc-movement
extends the movement phase from [70] by incorporating hierar-
chical community structures [80]. Unlike prior approaches, it op-
erates on a supergraph where each supervertex represents a sub-
community, focusing on hierarchical dependencies between com-
munities and their nested substructures. Inspired by the key tech-
nique of maintaining the connected components in dynamic graphs
[90], inc-refinement maintains sub-communities by using tree-
based structures to efficiently track changes in sub-communities.
Inc-aggregation updates the supergraph by computing structural
changes based on the outputs of the previous two phases.

We have evaluated HIT-Leiden on several large-scale real-world
dynamic graph datasets. The experimental results show that our
algorithm achieves comparable community quality with the state-
of-the-art algorithms for maintaining Leiden communities, while

MovementInputğ‘ƒiterationsOutputAggregationMovementAggregationInputğ‘ƒiterationsOutputRefinementOpt-movementAggregationInputOutputOpt-refinementLeidenInc-movementInc-aggregationInputğ‘ƒiterationsOutputInc-refinementEfficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

achieving up to five orders of magnitude faster than DF-Leiden. In
addition, we have deployed our algorithm in real-world applications
at ByteDance.

Outline. We first review related work in Section 2. We then for-
mally introduce some preliminaries, including the Leiden algorithm
and problem definition in Section 3, provide some theoretical anal-
ysis in Section 4, and present our proposed HIT-Leiden algorithm
in Section 5. Finally, we present the experimental results in Section
6 and conclude in Section 7.

2 Related Work
In this section, we first review the existing works of CD for both
static and dynamic graphs. We simply classify these works as mod-
ularity and other metrics-based CD methods.

â€¢ Modularity-based CD. Modularity-based CD methods aim to
partition a graph such that communities exhibit high internal con-
nectivity relative to a null model. Among these methods, Louvain
[10] is the most popular one due to its high efficiency and scalability
as shown in some comparative analyses [4, 39, 94]. Leiden [80] im-
proves upon Louvain by resolving the problem of disconnected com-
munities, yielding higher-quality results with comparable runtime.
Other modularity heuristics [19, 56, 58] or incorporate simulated
annealing [11, 37], spectral techniques [59], and evolutionary strate-
gies [42, 49]. Further refinements explore multi-resolution [77], ro-
bust optimization [5], normalized modularity [52], and clustering
cost frameworks [35]. Recent neural approaches have integrated
modularity objectives into deep learning models [9, 12, 89, 93, 100],
enhancing representation learning for CD.

Besides, some recent works have studied how to incrementally
maintain modularity-based communities when the graph is changed.
Aynaud et al. [6] proposed one of the earliest approaches by reusing
previous community assignments to warm-start the Louvain al-
gorithm. Subsequent works extended this idea to both Louvain
[18, 20, 53, 62, 69, 74, 75, 97] and Leiden [70], incorporating mecha-
nisms such as edge-based impact screening or localized modular-
ity updates. Nevertheless, the existing algorithms of maintaining
Leiden communities lack in-depth theoretical analysis, and their
practical efficiency is poor. Other methods based on modularity,
including extensions to spectral clustering [17], multi-step CD [7],
and label propagation-based methods [61, 86â€“88] have been studied
on dynamic graphs.

â€¢ Other metrics-based CD. Beyond modularity, various CD
methods have been developed by using different optimization pur-
poses, such as similarity, statistical inference, spectral clustering,
and neural networks. The similarity-based methods like SCAN
[23, 83, 92] identify dense regions from the graph via structural
similarity. Statistical inference approaches, including stochastic
block models [2, 29, 36, 64], infer communities by fitting genera-
tive probabilistic models to observed networks. Spectral clustering
methods [3, 22, 57] exploit the eigenstructure of graph Laplacians
to group nodes with similar structural roles. Deep learning-based
methods for CD have recently gained traction. Graph convolutional
networks [21, 31, 32, 40, 50, 76, 91, 101, 103], and graph attention
networks [26, 34, 51, 81, 84, 96] have demonstrated strong perfor-
mance in learning expressive node embeddings for CD tasks. For
more details, please refer to recent survey papers of CD [13, 78].

Table 1: Frequently used notations and their meanings.

Notation
ğº = (ğ‘‰ , ğ¸ )
ğ‘ (ğ‘£), ğ‘2 (ğ‘£)
ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘— )
ğ‘‘ (ğ‘£)
ğ‘š
C
ğ‘„
ğº ğ‘ =(ğ‘‰ ğ‘, ğ¸ğ‘ )
Î”ğ‘„ (ğ‘£ â†’ ğ¶ â€², ğ›¾ )
ğ‘“ (Â·): ğ‘‰ â†’ C
ğ‘“ ğ‘ (Â·): ğ‘‰ ğ‘ƒ â†’ C
ğ‘ ğ‘ (Â·):
ğ‘‰ ğ‘ â†’ ğ‘‰ ğ‘+1
Î”ğº

Meaning
A graph with vertex set ğ‘‰ and edge set ğ¸
The vertex ğ‘£â€™s 1- and 2-hop neighbor sets, resp.
The weight of edge between ğ‘£ğ‘– and ğ‘£ğ‘—
The weighted degree of vertex ğ‘£
The total weight of all edges in ğº
A set of communities forming a partition of ğº
The modularity of the graph ğº with partition C
The supergraph in the ğ‘-th iteration of Leiden
Modularity gain by moving ğ‘£ from ğ¶ to ğ¶ â€² with ğ›¾
A mapping from vertices to communities
A mapping from supervertices to communities
A mapping from supervertices in ğ‘-th level to
supervertices in (ğ‘ + 1)-th level (sub-communities)
The set of changed edges in the dynamic graph

Besides, many of the above methods have also been extended for
dynamic graphs. Ruan et al. [68] and Zhang et al. [98] have studied
structural graph clustering on dynamic graphs, which is based
on structural similarity. Temporal spectral methods [16, 17] and
dynamic stochastic block models [45, 72] enable statistical modeling
of evolving community structures over time. Recent deep learning
approaches also support dynamic CD through mechanisms such as
temporal embeddings [102], variational inference [41], contrastive
learning [15, 24, 85], and generative modeling [33]. These models
capture temporal dependencies and structural evolution.

3 Preliminaries
In this section, we first formally present the problem we study,
and then briefly introduce the original Leiden algorithm. Table 1
summarizes the notations frequently used throughout this paper.

3.1 Problem definition
We consider an undirected and weighted graph ğº = (ğ‘‰ , ğ¸),
where ğ‘‰ and ğ¸ are the sets of vertices and edges, respectively. Each
vertex ğ‘£â€™s neighbor set is denoted by ğ‘ (ğ‘£). Each edge (ğ‘£ğ‘–, ğ‘£ ğ‘— ) is
associated with a positive weight ğ‘¤ (ğ‘£ğ‘–, ğ‘£ ğ‘— ) > 0. The degree of ğ‘£ğ‘– is
given by ğ‘‘ (ğ‘£ğ‘– ) = âˆ‘ï¸ğ‘£ğ‘— âˆˆğ‘ (ğ‘£ğ‘– ) ğ‘¤ (ğ‘£ğ‘–, ğ‘£ ğ‘— ). Denote by ğ‘š the total weight
of all edges in ğº, i.e., ğ‘š = âˆ‘ï¸

(ğ‘£ğ‘– ,ğ‘£ğ‘— ) âˆˆğ¸ ğ‘¤ (ğ‘£ğ‘–, ğ‘£ ğ‘— ).

Given a graph ğº = (ğ‘‰ , ğ¸), the CD process aims to partition all
the vertices of ğ‘‰ into some disjoint sets C, each of which is called
a community, corresponding to a set of vertices that are densely
connected. This process can be modeled as a mapping function
ğ‘“ (Â·) : ğ‘‰ â†’ C, such that each ğ‘£ belongs to a community ğ‘“ (ğ‘£) of
the partition C. For each vertex ğ‘£, the total weight between ğ‘£ and a
community ğ¶ is denoted by ğ‘¤ (ğ‘£, ğ¶) = âˆ‘ï¸ğ‘£â€² âˆˆğ‘ (ğ‘£)âˆ©ğ¶ ğ‘¤ (ğ‘£, ğ‘£ â€²).

As a well-known CD metric, the modularity measures the differ-
ence between the actual number of edges in a community and the
expected number of such edges.

Definition 1 (Modularity [10]). Given a graph ğº = (ğ‘‰ , ğ¸) and
a community partition C over ğ‘‰ , the modularity ğ‘„ (ğº, C, ğ›¾) of the
graph ğº with the partition C is defined as:

ğ‘„ (ğº, C, ğ›¾ ) =

(ï¸„ 1
2ğ‘š

âˆ‘ï¸‚

ğ¶ âˆˆC

âˆ‘ï¸‚

ğ‘£ âˆˆğ¶

ğ‘¤ (ğ‘£, ğ¶ ) âˆ’ ğ›¾

)ï¸ƒ 2)ï¸„

,

(ï¸ƒ ğ‘‘ (ğ¶ )
2ğ‘š

(1)

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

Algorithm 1: Leiden algorithm [71, 79]
Input: ğº, ğ‘“ (Â·), ğ‘ƒ , ğ›¾
Output: Updated ğ‘“ (Â·)
1 ğº 1 â† ğº, ğ‘“ 1 (Â·) â† ğ‘“ (Â·);
2 for ğ‘ = 1 to ğ‘ƒ do
3

ğ‘“ ğ‘ (Â·) â† ğ‘€ğ‘œğ‘£ğ‘’ (ğºğ‘, ğ‘“ ğ‘ (Â·), ğ›¾ );
ğ‘ ğ‘ (Â·) â† ğ‘…ğ‘’ ğ‘“ ğ‘–ğ‘›ğ‘’ (ğº ğ‘, ğ‘“ ğ‘ (Â·), ğ›¾ );
if p < P then

4

5

6

ğº ğ‘+1, ğ‘“ ğ‘+1 (Â·) â† ğ´ğ‘”ğ‘”ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘¡ğ‘’ (ğº ğ‘, ğ‘“ ğ‘ (Â·), ğ‘ ğ‘ (Â·) );

7 Update ğ‘“ (Â·) using ğ‘ 1 (Â·), Â· Â· Â· , ğ‘ ğ‘ƒ (Â·);
8 return ğ‘“ (Â·);

where ğ‘‘ (ğ¶) is the total degree of all vertices in a community ğ¶, and
ğ›¾ > 0 is a superparameter.

Note that the parameter ğ›¾ > 0 controls the granularity of the
detected communities [67]. A higher ğ›¾ favors smaller, finer-grained
communities. In practice, ğ›¾ is often set to 0.5, 1, 4, or 32, as shown
in [46]. Besides, to guide community updates, the concept of modu-
larity gain is often used to capture the changed modularity when a
vertex is moved from one community to another.

Definition 2 (Modularity gain [10]). Given a graph ğº, a par-
tition C, and a vertex ğ‘£ that belongs to a community ğ¶, the modularity
gain of moving ğ‘£ from ğ¶ to another community ğ¶ â€² is defined as:

Î”ğ‘„ (ğ‘£ â†’ ğ¶ â€², ğ›¾ ) =

ğ‘¤ (ğ‘£, ğ¶ â€² ) âˆ’ ğ‘¤ (ğ‘£, ğ¶ )
2ğ‘š

+

ğ›¾ Â· ğ‘‘ (ğ‘£) Â· (ğ‘‘ (ğ¶ ) âˆ’ ğ‘‘ (ğ‘£) âˆ’ ğ‘‘ (ğ¶ â€² ) )
(2ğ‘š) 2

.

(2)

In this paper, we focus on the dynamic graph with insertions and
deletions of both vertices and edges. Since a vertex insertion (resp.
deletion) can be modeled as a sequence of edge insertions (resp.
deletions), we simply focus on edge changes. Given a set of edge
changes Î”ğº to a graph ğº = (ğ‘‰ , ğ¸), we obtain an updated graph
ğº â€² = (ğ‘‰ â€², ğ¸â€²). Since there are two types of edge updates, we let
Î”ğº = Î”ğº+ âˆª Î”ğº âˆ’, where Î”ğº+ = ğ¸â€² \ğ¸ and Î”ğº âˆ’ = ğ¸ \ğ¸â€² denote the
sets of inserted and deleted edges, respectively. We denote updated
edges (ğ‘£ğ‘–, ğ‘£ ğ‘—, ğ›¼) âˆˆ Î”ğº+ and (ğ‘£ğ‘–, ğ‘£ ğ‘—, âˆ’ğ›¼) âˆˆ Î”ğº âˆ’, where ğ›¼ is positive,
i.e., ğ›¼ > 0. We use ğº âŠ• Î”ğº to denote applying Î”ğº to ğº, yielding an
updated graph ğº â€².

We now formally introduce the problem studied in this paper.

Problem 1 (Maintenance of Leiden communities [70]). Given
a graph ğº with its Leiden communities C, and some edge updates Î”ğº,
return the updated Leiden communities after applying Î”ğº to ğº.

We illustrate our problem via Example 1.

Example 1. In Figure 1(a), the original graph ğº with unit edge
weights contains two Leiden communities: ğ¶1 = {ğ‘£1, ğ‘£2} and ğ¶2 =
{ğ‘£3, ğ‘£4, ğ‘£5, ğ‘£6, ğ‘£7, ğ‘£8}. After inserting a new edge (ğ‘£1, ğ‘£3) and deleting
an existing edge (ğ‘£3, ğ‘£5) into ğº, we obtain an updated graph ğº â€²,
which has two updated communities ğ¶1 = {ğ‘£1, ğ‘£2, ğ‘£3, ğ‘£4} and ğ¶2 =
{ğ‘£5, ğ‘£6, ğ‘£7, ğ‘£8}.

(a) All the communities.

(b) A tree-like structure.

Figure 4: The process of Leiden for the graph ğº in Figure 1(a).
mapping ğ‘“ 1 (Â·) be ğ‘“ (Â·), and sets up the sub-community mapping
ğ‘  (Â·) (line 1). Next, it iterates ğ‘ƒ times, each having three phases.

(1) Movement phase (line 3): for each supervertex ğ‘£ğ‘ in the
supergraph ğºğ‘ , it attempts to move ğ‘£ğ‘ to a neighboring
community that yields the maximum positive modularity
gain, resulting in an updated community mapping ğ‘“ ğ‘ (Â·).
(2) Refinement phase (line 4): it splits each community into
some sub-communities such that each of them corresponds
to a connected component, producing a sub-community map-
ping ğ‘ ğ‘ (Â·).

(3) Aggregation phase (line 6): when ğ‘ < ğ‘ƒ, it aggregates each
sub-community as a supervertex and builds a new graph
ğºğ‘+1.

Finally, after ğ‘ƒ iterations, we update ğ‘“ (Â·) and obtain the commu-
nities (lines 7-8). Note that ğ‘“ (Â·) is updated using ğ‘ ğ‘ƒ (Â·) rather than
ğ‘“ ğ‘ƒ (Â·) since sub-communities guarantee connectivity with com-
parable modularity. Besides, we use the terms supervertex and
sub-community interchangeably in this paper. A superedge is an
edge between two supervertices, and its weight is the sum of the
weights of edges between the supervertices.

Clearly, the vertices assigned to a sub-community will be further
aggregated as a supervertex, so all the vertices and supervertices
generated naturally form a tree-like hierarchical structure. The
total time complexity of Leiden is ğ‘‚ (ğ‘ƒ Â· (|ğ‘‰ | + |ğ¸|)) [71], since each
iteration costs ğ‘‚ (|ğ‘‰ | + |ğ¸|) time.

Example 2. Figure 4 (a) depicts the process of Leiden with ğ‘ƒ=3
for the graph in Figure 1. Denote by ğ‘£ğ‘
the supervertex (i.e., sub-
community) in the ğ‘-th iteration of Leiden. It generates three levels
of supergraphs: ğº 1, ğº 2, and ğº 3, with ğº 1 = ğº. The vertices of these
supergraphs form a tree-like structure, as shown in Figure 4(b).

ğ‘–

5, ğ‘£ 1

6, ğ‘£ 1

Take the first iteration as an example depicted in Figure 5. In
1, ğ‘£ 1
the movement phase, it generates three communities ğ¶1 = {ğ‘£ 1
2 },
ğ¶2 = {ğ‘£ 1
8 } and ğ¶3 = {ğ‘£ 1
7, ğ‘£ 1
4 }. In the refinement phase, ğ¶2 is
split into two sub-communities ğ‘£ 2
8 }, and
ğ¶1 and ğ¶2 are unchanged. In the aggregation phase, all vertices are
aggregated into supervertices based on their sub-community mem-
berships, resulting in ğº 2.

3, ğ‘£ 1
11 = {ğ‘£ 1

6 } and ğ‘£ 2

12 = {ğ‘£ 1

7, ğ‘£ 1

5, ğ‘£ 1

4 Theoretical Analysis of Leiden
In this section, we first analyze the boundedness of existing al-
gorithms, then study how vertex behavior impacts community
structure under graph updates, and extend it to supergraphs.

3.2 Leiden algorithm
Algorithm 1 presents Leiden [71, 79], following the process in Fig-
ure 2(b). Given a graph ğº, and an initial mapping ğ‘“ (Â·) (w.l.o.g.,
ğ‘“ (ğ‘£) = {ğ‘£ }), it first initializes the level-1 supergraph ğº 1, lets level-1

4.1 Boundedness analysis
We first introduce some concepts related to boundedness.

â€¢ Notation. Let Î˜ denote the CD query applied to a graph ğº,
where Î˜(ğº) = C is the set of detected communities. The new graph

ğ‘£!"ğ‘£#$"ğ‘£##"ğ‘£#""ğ‘£#%&ğ‘£#&&ğ‘£"#ğ‘£##ğ‘£%#ğ‘£&#ğ‘£'#ğ‘£(#ğ‘£)#ğ‘£*#ğ‘£!!ğ‘£"!ğ‘£#!ğ‘£$!ğ‘£%!ğ‘£&!ğ‘£'"ğ‘£!!"ğ‘£!""ğ‘£!((ğ‘£!)(ğ‘£)!ğ‘£(!ğ‘£!*"Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

(a) The process of hierarchical partitions at the first iteration on the graph.

(b) The tree-like structure.

Figure 5: The process of hierarchical partitions of Figure 4 at level-1 with the Leiden algorithm.

is ğº âŠ• Î”ğº, and the updated community is Î˜(ğº âŠ• Î”ğº). We denote
the output difference as Î”C, where Î˜(ğº âŠ• Î”ğº) = Î˜(ğº) âŠ• Î”C.

â€¢ Concepts of boundedness. The notion of boundedness [66]
evaluates the effectiveness of an incremental algorithm using the
metric CHANGED, defined as CHANGED = Î”ğº + Î”C, which leads to
|CHANGED| = |Î”ğº | + |Î”C|.

Definition 3 (Boundedness [25, 66]). An incremental algorithm
is bounded if its computational cost can be expressed as a polynomial
function of |CHANGED| and |Î˜|. Otherwise, it is unbounded.

â€¢ Concepts of relative boundedness. In real-world dynamic
graphs, |CHANGED| is often small, yet some unbounded algorithms
can be solved in polynomial time using measures comparable to
|CHANGED|, making these algorithms feasible. To assess these incre-
mental algorithms effectively, Fan et al. [25] introduced the concept
of relative boundedness, which leverages a more refined cost model
called the affected region. Let AFF denote the affected part, the re-
gion of the graph actually processed by the incremental algorithm.

Definition 4 (AFF [25]). Given a graph ğº, a query Î˜, and the
input update Î”ğº to ğº, AFF signifies the cost difference of the static
algorithm between computing Î˜(ğº) and Î˜(ğº âŠ• Î”ğº).

Unlike CHANGED, AFF captures the concrete portion of the graph
touched by an incremental algorithm, providing a tighter bound
on its computational cost. This leads to the following definition.

Definition 5 (Relative boundedness [25]). An incremental
graph algorithm is relatively bounded to the static algorithm if its
cost is polynomial in |Î˜| and |AFF|.

We now analyze the boundedness of existing incremental Leiden

algorithms.

Theorem 1. When processing an edge deletion or insertion, the
incremental Leiden algorithms proposed in [70] all cost ğ‘‚ (ğ‘ƒ Â· (|ğ‘‰ | +
|ğ¸|)).

Table 2: Incremental Leiden algorithms

Method

Time complexity

Relative
boundedness
âœ—
âœ—
âœ—
âœ“

ST-Leiden [70]
DS-Leiden [70]
DF-Leiden [70]
HIT-Leiden

ğ‘‚ (ğ‘ƒ Â· ( |ğ‘‰ | + |ğ¸ | ) )
ğ‘‚ (ğ‘ƒ Â· ( |ğ‘‰ | + |ğ¸ | ) )
ğ‘‚ (ğ‘ƒ Â· ( |ğ‘‰ | + |ğ¸ | ) )
ğ‘‚ ( |ğ‘2 (CHANGED) | + |ğ‘2 (AFF) | )
By Theorem 1, the existing algorithms for maintaining Leiden
communities are both unbounded and relatively unbounded as
shown in Table 2. They are very costly for large graphs, even with
a small update. Following, we review the property of Leiden and
then identify AFF of Leiden in the end.

4.2 Vertex optimality and subpartition ğ›¾-density
As shown in the literature [10, 80], if ğ‘ ğ‘ƒ (Â·) = ğ‘“ ğ‘ƒ (Â·) after ğ‘ƒ iterations,
Leiden is guaranteed to satisfy the following two properties:

â€¢ Vertex optimality: All the vertices are vertex optimal.
â€¢ Subpartition ğ›¾-density: All the communities are subparti-

tion ğ›¾-dense.

To design an efficient and effective maintenance algorithm for
Leiden communities, we analyze the behaviors of vertices and com-
munities when the graph changes as follows.

â€¢ Analysis of vertex optimality. We begin with a key concept.

Definition 6 (Vertex optimality [10]). A community ğ¶ âˆˆ C
is called vertex optimality if for each vertex ğ‘£ âˆˆ ğ¶ and ğ¶ â€² âˆˆ C, the
modularity gain Î”ğ‘„ (ğ‘£ â†’ ğ¶ â€², ğ›¾) â‰¤ 0.

Next, we introduce an assumption in the maintenance of Louvain

communities [69, 97]:

Assumption 1. The sum of weights of the updated edges is suffi-

ciently small relative to the graph size ğ‘š.

Based on Assumption 1, prior studies suggest that when the num-
ber of edge updates is small relative to the graph size, three heuris-
tics hold: (1) intra-community edge deletions and inter-community
edge insertions could affect vertex-level community membership [69,
97]; (2) Inter-community edge deletions and intra-community edge
insertions can be ignored [69, 97]; (3) Vertices directly involved
in such edge changes are the most likely to alter their communi-
ties [69]. The heuristics are stated in Observation 1, which can be
proved based on Definition 6.

Observation 1 ([69]). Given an intra-community edge deletion
(ğ‘£ğ‘–, ğ‘£ ğ‘—, âˆ’ğ›¼) or a cross-community edge insertion (ğ‘£ğ‘–, ğ‘£ ğ‘—, ğ›¼), its effect on
the community memberships of vertices ğ‘£ğ‘– and ğ‘£ ğ‘— can not be ignored.

We further derive the propagation of community changes from

Observation 1.

Lemma 1. When a vertex ğ‘£ changes its community to ğ¶, then the
communities of its neighbors not in ğ¶ in the updated graph could be
affected.

Proof. Assuming ğ‘£ changes its community from ğ¶ğ‘– to ğ¶, there

are three cases:

(1) For each neighbor ğ‘£ğ‘– in ğ¶ğ‘– , the edge (ğ‘£, ğ‘£ğ‘– ) is a deleted intra-
community edge and an inserted cross-community edge;
(2) For each neighbor ğ‘£ ğ‘— in ğ¶, the edge (ğ‘£, ğ‘£ ğ‘— ) is a deleted cross-
community edge and an inserted intra-community edge;
(3) For each other neighbor ğ‘£ğ‘˜ , edge (ğ‘£, ğ‘£ğ‘˜ ) is a deleted cross-
community edge and an inserted cross-community edge.

MovementRefinementAggregationğº!ğº!ğº!ğº"ğ‘£#ğ‘£$ğ‘£%ğ‘£&ğ‘£!ğ‘£"ğ‘£'ğ‘£(ğ‘£#ğ‘£$ğ¶!ğ‘£%ğ‘£&ğ‘£!ğ‘£"ğ‘£'ğ‘£(ğ¶'ğ‘£!ğ‘£"ğ‘£)"ğ‘£'ğ‘£(ğ‘£!*"ğ‘£#ğ‘£$ğ‘£%ğ‘£&ğ‘£!!"ğ‘£!""ğ¶!ğ¶'ğ¶"ğ¶"ğ¶!ğ¶'ğ‘£!""ğ‘£)"ğ‘£!*"ğ‘£!!"ğ¶"ğ‘£!!"ğ‘£#!ğ‘£$!ğ‘£%"ğ‘£!!ğ‘£"!ğ¶!ğ¶&ğ‘£!""ğ‘£'!ğ‘£(!ğ‘£!)"ğ‘£*!ğ‘£&!ğ¶"SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

(a) A triangle.

(b) Delete an edge.
Figure 6: An example for illustrating subpartition ğ›¾-density.
Since only the first and third cases meet the conditions in Observa-
tion 1, all the neighbors of ğ‘£ that are not in ğ¶ are likely to change
â–¡
their communities.

(c) Delete two edges.

Based on these analyses, we develop a novel movement phase,
called inc-movement in HIT-Leiden to preserve vertex optimality,
which will be introduced in Section 5.1.

â€¢ Analysis of subpartition ğ›¾-density. For simplified analy-
sis, we first introduce ğ›¾-order and ğ›¾-connectivity, which are key
concepts for defining subpartition ğ›¾-density.

Definition 7 (ğ›¾-order). Given two vertex sequences ğ‘‹ and ğ‘Œ of
a graph ğº, let ğ‘‹ âŠ— ğ‘Œ represent that ğ‘Œ is merged into ğ‘‹ such that 2ğ‘š Â·
ğ‘¤ (ğ‘‹, ğ‘Œ ) â‰¥ ğ›¾ Â· ğ‘‘ (ğ‘‹ ) Â· ğ‘‘ (ğ‘Œ ), where ğ‘¤ (ğ‘‹, ğ‘Œ ) = âˆ‘ï¸ğ‘£ğ‘– âˆˆğ‘‹ âˆ‘ï¸ğ‘£ğ‘— âˆˆğ‘Œ ğ‘¤ (ğ‘£ğ‘–, ğ‘£ ğ‘— ).
A ğ›¾-order of a vertex sequence ğ‘ˆ = {ğ‘£1, Â· Â· Â· , ğ‘£ğ‘¥ } represents the merged
sequence starting from singleton sequences {ğ‘£1}, Â· Â· Â· , {ğ‘£ğ‘¥ }.

We can maintain one ğ›¾-order per sub-community from Leiden,
which is represented by the sequence of vertices merging into the
sub-community in refinement phase of Leiden.

Definition 8 (ğ›¾-connectivity [80]). Given a graph ğº, a vertex
sequence ğ‘ˆ is ğ›¾-connected if ğ‘ˆ can be generated from at least one
ğ›¾-order.

Definition 9 (Subpartition ğ›¾-density [80]). A vertex sub-
sequence ğ‘ˆ âŠ† ğ¶ âˆˆ C is subpartition ğ›¾-dense if ğ‘ˆ is ğ›¾-connected,
and any intermediate vertex sequence ğ‘‹ is locally optimized, i.e.,
Î”ğ‘„ (ğ‘‹ â†’ âˆ…, ğ›¾) â‰¤ 0.

Notably, Î”ğ‘„ (ğ‘‹ â†’ âˆ…, ğ›¾) â‰¤ 0 denotes the modularity gain of
moving ğ‘‹ from ğ¶ to an empty set, whose calculation follows the
same formula as the standard modularity gain in Equation (2).

Example 3. The triangle in Figure 6(a) is subpartition ğ›¾-dense
with ğ›¾ = 1 since there are six different ğ›¾-orders. For instance, one is
{ğ‘£3} âŠ— ({ğ‘£1} âŠ— {ğ‘£2}), which represents that ğ‘£2 is merged into {ğ‘£1}
generating sequence {ğ‘£1, ğ‘£2}, and then {ğ‘£1, ğ‘£2} merges into ğ‘£3 gen-
erating {ğ‘£1, ğ‘£2, ğ‘£3}. After deleting the edge (ğ‘£1, ğ‘£2), although {ğ‘£3} âŠ—
({ğ‘£1} âŠ— {ğ‘£2}) is not a ğ›¾-order, the update graph is still subpartition
ğ›¾-dense since {ğ‘£1} âŠ— ({ğ‘£2} âŠ— {ğ‘£3}) is a ğ›¾-order in the update graph.
After continuing to delete the edge (ğ‘£2, ğ‘£3), the updated graph is not
subpartition ğ›¾-dense since ğ‘£2 is not connected to ğ‘£1 and ğ‘£3.

In essence, each community ğ¶ (or sub-community ğ‘†) of Leiden
is subpartition ğ›¾-dense, since (1) any sub-community in ğ¶ (or ğ‘†)
is locally optimized, and (2) all sub-communities are ğ›¾-connected.
Notably, as shown in Figure 3(b), vertex optimality ensures the first
condition by design since any sub-community will be a supervertex
in inc-movement of the next iteration. Thus, we will develop a new
refinement algorithm, inc-refinement, to preserve ğ›¾-connectivity
of sub-communities.

Next, we analyze the ğ›¾-connectivity property under two kinds
of graph updates, i.e., edge deletion and edge insertion. For any
vertex ğ‘£ğ‘– within a sub-community ğ‘†ğ‘– with a ğ›¾-order, we denote an
intermediate subsequence of the ğ›¾-order containing ğ‘£ğ‘– by ğ¼ğ‘– âŠ† ğ‘†ğ‘– ,

and the subsequence ğ‘ˆğ‘– = ğ¼ğ‘– \ {ğ‘£ğ‘– } is an intermediate subsequence
of the ğ›¾-order before merging ğ‘£ğ‘– . For lack of space, all the proofs of
lemmas are shown in the appendix of the full version [44] of this
paper.

(1) Edge deletion. We consider the deletions of both intra-sub-

community edges and cross-sub-community edges:

Lemma 2. Given an intra-sub-community edge deletion (ğ‘£ğ‘–, ğ‘£ ğ‘—, âˆ’ğ›¼),
assume ğ‘£ ğ‘— is before ğ‘£ğ‘– in the ğ›¾-order of the sub-community. The effects
of the edge deletion can be described by the following four cases:

(1) ğ‘£ğ‘– could be removed from its sub-community only if ğ›¼ >

(2) ğ‘£ ğ‘— could be removed from its sub-community only if ğ›¼ > ğ‘š âˆ’

2ğ‘šÂ·ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– ) âˆ’ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘– ) Â·ğ‘‘ (ğ‘ˆğ‘– )
4ğ‘š+2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )

;

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘— ) Â·ğ‘‘ (ğ‘ˆ ğ‘— )
2ğ‘¤ (ğ‘£ğ‘— ,ğ‘ˆ ğ‘— )

;

(3) For any ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– (ğ‘˜ â‰  ğ‘–, ğ‘—), it could be removed from its sub-

community only if ğ›¼ > ğ‘š âˆ’

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ ) Â·ğ‘‘ (ğ‘ˆğ‘˜ )
2ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )

;

(4) For any ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– , it should be removed from its sub-community
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘™ ) Â·ğ‘‘ (ğ‘ˆğ‘™ ) )
2ğ‘¤ (ğ‘£ğ‘™ ,ğ‘ˆğ‘™ )

if and only if ğ›¼ > ğ‘š âˆ’

.

Lemma 3. Given a cross-sub-community edge deletion (ğ‘£ğ‘–, ğ‘£ ğ‘—, âˆ’ğ›¼),
the effects of the edge deletion can be described by the following four
cases:

(1) ğ‘£ğ‘– could be removed from its sub-community only if ğ›¼ > ğ‘š âˆ’

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘– ) Â·ğ‘‘ (ğ‘ˆğ‘– )
2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )

;

(2) ğ‘£ ğ‘— holds similar behavior with ğ‘£ğ‘– ;
(3) For any ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– âˆª ğ‘† ğ‘— (ğ‘˜ â‰  ğ‘–, ğ‘—), it could be removed its sub-

community only if ğ›¼ > ğ‘š âˆ’

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ ) Â·ğ‘‘ (ğ‘ˆğ‘˜ )
2ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )

;

(4) For any ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– âˆªğ‘† ğ‘— , it could be removed from its sub-community
.

only if ğ›¼ > ğ‘š âˆ’

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘™ ) Â·ğ‘‘ (ğ‘ˆğ‘™ )
2ğ‘¤ (ğ‘£ğ‘™ ,ğ‘ˆğ‘™ )

(2) Edge insertion. We consider the insertion of edges containing
the insertions of both intra-sub-community edges and cross-sub-
community edges:

Lemma 4. Given an edge insertion (ğ‘£ğ‘–, ğ‘£ ğ‘—, ğ›¼), the effects of the edge

insertion can be described by the following four cases:

(1) ğ‘£ğ‘– could be removed from its sub-community only if ğ›¼ > 4
Â· ğ‘š âˆ’ ğ‘‘ (ğ‘£ğ‘– );
(2) ğ‘£ ğ‘— could be removed from its sub-community, only if ğ›¼ >

ğ‘‘ (ğ¼ğ‘– ) or ğ›¼ > 2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )
ğ›¾ Â·ğ‘‘ (ğ‘ˆğ‘– )

ğ›¾ ğ‘š âˆ’

2ğ‘¤ (ğ‘£ğ‘— ,ğ‘ˆ ğ‘— )
ğ›¾ Â·ğ‘‘ (ğ‘ˆ ğ‘— )

Â· ğ‘š âˆ’ ğ‘‘ (ğ‘£ ğ‘— );

(3) For any ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– âˆª ğ‘† ğ‘— (ğ‘˜ â‰  ğ‘–, ğ‘—), it could be removed from its

sub-community, only if ğ›¼ > ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ )
(4) For any ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– âˆª ğ‘† ğ‘— , it is unaffected.

Â· ğ‘š âˆ’ 1

2ğ‘‘ (ğ‘ˆğ‘˜ );

Observation 2. In the refinement phase of Leiden algorithms,
each vertex ğ‘£ is likely to be merged into the sub-community (interme-
diate subsequence ğ‘ˆ ), offering more edge weights ğ‘¤ (ğ‘£, ğ‘ˆ ) and smaller
degrees ğ‘‘ (ğ‘ˆ ). Therefore, the differences of the values of ğ‘‘ (ğ‘£), ğ‘¤ (ğ‘£, ğ‘ˆ ),
and ğ‘‘ (ğ‘ˆ ) are very small when the traversal order of vertices to be
merged into sub-communities is in ascending order of vertex degree.

By the above observation, ğ›¼ is unlikely to satisfy the conditions
in cases (2)-(4) of Lemma 2, all the cases of Lemma 3, and the
conditions in cases (1)-(3) of Lemma 4 when ğ›¼ â‰ª ğ‘š (which is often
true as stated in Assumption 1). As a result, when designing the

ğ‘£!ğ‘£"ğ‘£#ğ‘£!ğ‘£"ğ‘£#ğ‘£!ğ‘£"ğ‘£#Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

maintenance algorithm, we only need to consider the effect of intra-
sub-community edge deletions on ğ‘£ğ‘– , which cannot be ignored.

Besides, our experiments show the following observation, which

shows that the case (1) of Lemma 2 can also be ignored.

Observation 3. Given an updated graph with its previous sub-
community memberships, for any sub-community ğ‘†, we treat each
connected component in ğ‘† as a new sub-community. Most of the
maintained communities are subpartition ğ›¾-dense.

The above observation holds because Leiden only offers us a
ğ›¾-order from the refinement phase, and a subgraph often exists
with multiple distinct ğ›¾-orders as shown in Example 3. Besides, if a
vertex is a candidate affecting ğ›¾-connectivity, it is often a candidate
affecting vertex optimality, e.g., the vertex ğ‘£2 in Figure 6(c). In this
case, the vertex is likely to change its community before verifying
whether the vertex needs to move out of its sub-community. Hence,
the case (1) of Lemma 2 can be ignored if the intra-sub-community
edge deletion does not cause the sub-community to be disconnected.
Based on Observations 2-3, we develop a novel refinement al-
gorithm, called inc-refinement, in HIT-Leiden, which will be
introduced in Section 5.2. As shown in Figures 13 and Figure 14(b),
over 99% maintained communities from HIT-Leiden are subparti-
tion ğ›¾-dense.

Extension to supergraphs. Changes at the lower level propa-
gate upward to superedge changes in the higher-level supergraph,
as Leiden constructs a list of supergraphs in a bottom-up manner.
This motivates us to develop an incremental aggregation phase,
namely inc-aggregation, to compute the superedge changes in
Section 5.3.

Example 4. In Figure 1, communities ğ¶1 and ğ¶2 are treated as su-
pervertices. Deleting an edge (ğ‘£3, ğ‘£5, 1) and inserting an edge (ğ‘£1, ğ‘£3, 1)
cause ğ‘£3 and ğ‘£4 to move from ğ¶2 to ğ¶1. This results in the deletion of
(ğ¶2, ğ¶2, âˆ’2) and insertion of (ğ¶1, ğ¶1, 2) in the supergraph.

Therefore, we treat each supergraph as a set of facing edge
changes from the previous Leiden community and process them
using a consistent procedure as shown in Figure 3(b).

Characterization of AFF. Based on these analyses, we define
the supervertices that change their communities or sub-communities
as the affected area AFF of Leiden.

5 Our HIT-Leiden algorithm

if ğ‘  (ğ‘£ğ‘– ) = ğ‘  (ğ‘£ğ‘— )and ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’_ğ‘’ğ‘‘ğ‘”ğ‘’ (ï¸ğºÎ¨, (ğ‘£ğ‘–, ğ‘£ğ‘— , ğ›¼ ))ï¸ then

ğ¾ .ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘– ); ğ¾ .ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘— );

Algorithm 2: Inc-movement
Input: ğº, Î”ğº, ğ‘“ (Â·), ğ‘  (Â·), Î¨, ğ›¾
Output: Updated ğ‘“ (Â·), Î¨, ğµ, ğ¾

1 ğ´ â† âˆ…, ğµ â† âˆ…, ğ¾ â† âˆ…;
2 for (ğ‘£ğ‘–, ğ‘£ğ‘— , ğ›¼ ) âˆˆ Î”ğº do
3

if ğ›¼ > 0 and ğ‘“ (ğ‘£ğ‘– ) â‰  ğ‘“ (ğ‘£ğ‘— ) then
ğ´.ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘– ); ğ´.ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘— );
if ğ›¼ < 0 and ğ‘“ (ğ‘£ğ‘– ) = ğ‘“ (ğ‘£ğ‘— ) then
ğ´.ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘– ); ğ´.ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘— );

9 for ğ´ â‰  âˆ… do
10

ğ‘£ğ‘– â† ğ´.ğ‘ğ‘œğ‘ ();
ğ¶âˆ— â† ğ‘ğ‘Ÿğ‘”ğ‘šğ‘ğ‘¥ğ¶ âˆˆCâˆªâˆ… Î”ğ‘„ (ğ‘£ğ‘– â†’ ğ¶, ğ›¾ );
if Î”ğ‘„ (ğ‘£ğ‘– â†’ ğ¶âˆ—, ğ›¾ ) > 0 then
ğ‘“ (ğ‘£ğ‘– ) â† ğ¶âˆ—; ğµ.ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘– );
for ğ‘£ğ‘— âˆˆ ğ‘ (ğ‘£ğ‘– ) do

4

5

6

7

8

11

12

13

14

15

16

17

18

19

if ğ‘“ (ğ‘£ğ‘— ) â‰  ğ¶âˆ— then
ğ´.ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘— );

for ğ‘£ğ‘— âˆˆ ğ‘ (ğ‘£ğ‘– ) âˆ§ ğ‘  (ğ‘£ğ‘– ) = ğ‘  (ğ‘£ğ‘— ) do

if ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’_ğ‘’ğ‘‘ğ‘”ğ‘’ (ï¸ğºÎ¨, (ğ‘£ğ‘–, ğ‘£ğ‘— , âˆ’ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘— ) ))ï¸ then

ğ¾ .ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘– ); ğ¾ .ğ‘ğ‘‘ğ‘‘ (ğ‘£ğ‘— );

20 return ğ‘“ (Â·), Î¨, ğµ, ğ¾;

5.1 Inc-movement
The goal of inc-movement is to preserve vertex optimality. As an-
alyzed in Section 4.2, the endpoints of a deleted intra-community
edge or an inserted cross-community edge may affect their com-
munity memberships. If an affected vertex changes its community,
its neighbors outside the target community may also be affected.
Note that any vertex that changes its community has to change its
sub-community, since each sub-community is a subset of its com-
munity. Hence, sub-community memberships are also considered
in inc-movement.

We first introduce the data structures used to maintain a dynamic
sub-community. According to Observation 3, each connected com-
ponent of a sub-community is treated as a ğ›¾-connected subset.
When edge updates or vertex movements split a sub-community
into multiple connected components, we re-assign each result-
ing component as a new sub-community, and the largest sub-
community succeeds the original sub-communityâ€™s ID.

Figure 7: The design rationale for inc-movement and
inc-refinement.

In this section, we first introduce the three key components,
namely inc-movement, inc-refinement, and inc-aggregation
of our HIT-Leiden. Figure 7 shows the assumption, lemmas, and
observations used in these components. Then, we present an auxil-
iary procedure, called deferred update, abbreviated as def-update.
Afterward, we give an overview of HIT-Leiden, and finally analyze
the boundedness of HIT-Leiden.

(a) Original graph.

(c) Move out a vertex.
(b) Delete two edges.
Figure 8: Illustrating the process that a sub-community ğ‘†1 is
split into two sub-communities ğ‘†1 and ğ‘†2.

Example 5. Figure 8 shows the sub-community ğ‘†1 is split into two
sub-communities ğ‘†1 = {ğ‘£1, ğ‘£3} and ğ‘†2 = {ğ‘£2}. The component {ğ‘£1, ğ‘£3}
retains the original sub-community ID ğ‘†1, since it is larger than {ğ‘£2}.
The separation can occur either due to the deletion of edges (ğ‘£1, ğ‘£2)
and (ğ‘£2, ğ‘£3) during graph updates, as shown in Figure 8(b), or due
to the removal of vertex ğ‘£2 during the movement phase, as shown in
Figure 8(c).

Observation1Observation3Assumption1Inc-movementInc-refinementLemma 2Lemma 3Lemma 4Lemma1Observation2ğ‘£!ğ‘£"ğ‘£#ğ‘†!ğ‘£!ğ‘£"ğ‘£#ğ‘†!ğ‘†#ğ‘£!ğ‘£"ğ‘£#ğ‘†!ğ‘†#SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

Algorithm 3: Inc-refinement

Input: ğº, ğ‘“ (Â·), ğ‘  (Â·), Î¨, ğ¾, ğ›¾
Output: Updated ğ‘  (Â·), Î¨, ğ‘…,

1 ğ‘… â† âˆ…;
2 for ğ‘£ğ‘– âˆˆ ğ¾ do
3

if ğ‘£ğ‘– is not in the largest connected component of ğ‘  (ğ‘£) then

4

Map all vertices in the connected component into a new

sub-community and add them into ğ‘…;

5 for ğ‘£ğ‘– âˆˆ ğ‘… do
6

if ğ‘£ğ‘– is in singleton sub-community then

7

8

9

10

11

12

13

T â† {ğ‘  (ğ‘£) |ğ‘£ âˆˆ ğ‘ (ğ‘£ğ‘– ) âˆ© ğ‘“ (ğ‘£ğ‘– ), Î”ğ‘„ (ğ‘  (ğ‘£) â†’ âˆ…, ğ›¾ ) â‰¤ 0};
ğ‘† âˆ— â† ğ‘ğ‘Ÿğ‘”ğ‘šğ‘ğ‘¥ğ‘† âˆˆT Î”ğ‘€ (ğ‘£ğ‘– â†’ ğ‘†, ğ›¾ );
if Î”ğ‘€ (ğ‘£ğ‘– â†’ ğ‘† âˆ—, ğ›¾ ) > 0 then

ğ‘  (ğ‘£ğ‘– ) â† ğ‘† âˆ—;
for ğ‘£ğ‘— âˆˆ ğ‘ (ğ‘£ğ‘– ) do

if ğ‘  (ğ‘£ğ‘– ) = ğ‘  (ğ‘£ğ‘— ) then

ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’_ğ‘’ğ‘‘ğ‘”ğ‘’ (ï¸ğºÎ¨, (ğ‘£ğ‘–, ğ‘£ğ‘— , ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘— ) ))ï¸;

14 return ğ‘  (Â·), Î¨, ğ‘…;

To preserve the structure under such changes, we leverage dy-
namic connected component maintenance techniques. Various index-
based methods have been proposed for this purpose, such as D-Tree
[14], DND-Tree [90], and HDT [30]. Let Î¨ denote a connected com-
ponent index, abbreviated as CC-index. The graph ğºÎ¨ stores the
subgraph of ğº consisting only of intra-sub-community edges based
on ğ‘  (Â·).

Algorithm 2 shows inc-movement. Given an updated graph
ğº, a set of graph changes Î”ğº, community mappings ğ‘“ (Â·), sub-
community mappings ğ‘  (Â·), and a CC-index Î¨, it first initializes three
empty sets: ğ´, ğµ and ğ¾ (line 1). Here, ğ´ keeps the vertices whose
community memberships may be changed, ğµ keeps the vertices that
have changed their community memberships, and ğ¾ records the
endpoints on edges whose deletion disconnects the connected com-
ponent in ğºÎ¨. Subsequently, vertices involved in intra-community
edge deletion or cross-community edge insertion are added to ğ´,
and edges in ğºÎ¨ are updated according to intra-sub-community
changes (lines 2-7) based on Observations 1 and 3, respectively. If
an edge update in ğºÎ¨ causes a connected component to split (i.e.,
ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’_ğ‘’ğ‘‘ğ‘”ğ‘’ (Â·) returns ğ‘¡ğ‘Ÿğ‘¢ğ‘’), its endpoints are added to ğ¾ (line 8).
It then processes vertices in ğ´ until the set is empty (line 9). For
each vertex ğ‘£ğ‘– , it identifies the target community ğ¶âˆ— that yields the
highest modularity gain (lines 10-11). If Î”ğ‘„ (ğ‘£ğ‘– â†’ ğ¶âˆ—) > 0, ğ‘“ (ğ‘£ğ‘– )
is updated to ğ¶âˆ—, ğ‘£ğ‘– is added into ğµ, and the neighbors of ğ‘£ğ‘– not in
ğ¶âˆ— are added to ğ´ (lines 12-16), which implements the property in
Lemma 1. Besides, the intra-sub-community edges involving ğ‘£ğ‘– are
deleted from ğºÎ¨, and the vertices involved in component splits are
added to ğ¾ (lines 17-19). Finally, it returns ğ‘“ (Â·), Î¨, ğµ, and ğ¾ (line
20).

5.2 Inc-refinement
As discussed in Section 5.1 and Observation 3, we treat each con-
nected component in ğºÎ¨ maintained in inc-movement as a sub-
community. Therefore, we design inc-refinement for re-assigning
each new connected component in ğºÎ¨ as a sub-community. Addi-
tionally, we attempt to merge singleton sub-communities whose

process is the same as the process of the refinement phase in Leiden
with ğºÎ¨ maintenance.

Algorithm 3 presents its pseudocode. Given an updated graph
ğº, community mappings ğ‘“ (Â·) and sub-community mapping ğ‘  (Â·),
a CC-index Î¨, and a set ğ¾, it first initializes ğ‘… as an empty list
to track vertices that have changed their sub-communities (line
1). Note that ğ‘… is an ordered list sorted in ascending vertex de-
gree mentioned in Observation 2. It then traverses ğ¾ to identify
split connected components in ğºÎ¨ using breadth-first search or
depth-first search. If a connected component is not the largest in
its original sub-community, all its vertices are re-mapped to a new
sub-community, and added to ğ‘… (lines 2-4). If multiple components
tie for the largest component, one of them is randomly selected
to represent the original sub-community. For each vertex ğ‘£ğ‘– âˆˆ ğ‘…
that is in a singleton sub-community, inc-refinement uses a set
T to store the locally optimized neighboring sub-communities of
ğ‘£ğ‘– within the same community (lines 5-7). Then, it attempts to re-
assign ğ‘£ğ‘– to a sub-community ğ‘† âˆ— âˆˆ T , which offers the highest
modularity gain to eliminate singleton sub-communities (line 8).
Notably, Î”ğ‘€ (ğ‘£ğ‘– â†’ ğ‘†, ğ›¾) denotes the modularity gain of moving ğ‘£ğ‘–
from ğ‘  (ğ‘£ğ‘– ) to ğ‘†, whose calculation follows the same formula as the
standard modularity gain. If the gain is positive, ğ‘  (ğ‘£ğ‘– ) is updated to
ğ‘† âˆ—, and the corresponding intra-sub-community edges are inserted
into ğºÎ¨ (lines 9-13). Finally, inc-refinement returns the ğ‘  (Â·), Î¨,
and ğ‘… (line 14).

5.3 Inc-aggregation
Given an updated graph ğº and its edge changes Î”ğº, modifications
to edges and sub-community memberships are reflected as changes
to superedges and supervertices in the supergraph ğ» . Let ğ‘ ğ‘ğ‘Ÿğ‘’ (Â·)
(resp. ğ‘ ğ‘ğ‘¢ğ‘Ÿ (Â·)) denotes the vertex-to-supervertex mappings before
(resp. after) inc-refinement. Any edge change (ğ‘£ğ‘–, ğ‘£ ğ‘—, ğ›¼) in Î”ğº cor-
responds to a superedge change (ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘– ), ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ ğ‘— ), ğ›¼) in ğ» , since
the weight of a superedge is the sum of weights of edges between
their sub-communities. Besides, a vertex ğ‘£ migration from ğ‘ pre (ğ‘£)
to ğ‘ cur (ğ‘£) requires updating these weights. Specifically, the original
sub-community ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£) must decrease the superedge weights cor-
responding to the edge incident to ğ‘£, and the new sub-community
ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£) must increase them under the new assignment.

Example 6. Following Example 4, the initial superedge changes
due to edge changes are (ğ¶1, ğ¶2, 1) and (ğ¶2, ğ¶2, âˆ’1). Then, vertices ğ‘£3
and ğ‘£4 move from ğ¶2 to ğ¶1, and there are three cases:

(1) ğ¶1 gains edges to the neighbors of ğ‘£3, resulting in two updates:

(ğ¶1, ğ¶1, 1) and (ğ¶1, ğ¶1, 1);

(2) ğ¶2 loses edges to the neighbor of ğ‘£3 are (ğ¶1, ğ¶2, âˆ’1) and (ğ¶2, ğ¶2, âˆ’1);
(3) The effect of ğ‘£4 is skipped to avoid duplicate updates, since its

only neighbor ğ‘£3 already changed.

After compressing the above six superedge changes, we obtain the
final superedge changes, which are (ğ¶1, ğ¶1, 2) and (ğ¶2, ğ¶2, âˆ’2).

Algorithm 4 presents inc-aggregation. Initially, the set of chan-
ges Î”ğ» of ğ» is empty (line 1). Then, it maps the edge changes Î”ğº
to superedge changes using ğ‘ ğ‘ğ‘Ÿğ‘’ (Â·) (lines 2-4). Following, it updates
superedges for vertices that switch sub-communities by removing
edges from the old community and adding edges to the new one. For
any vertex ğ‘£ğ‘– in ğ‘…, if updates superedges with each neighbor ğ‘£ ğ‘— if

Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Algorithm 4: Inc-aggregation
Input: ğº, Î”ğº, ğ‘ ğ‘ğ‘Ÿğ‘’ (Â·), ğ‘ ğ‘ğ‘¢ğ‘Ÿ (Â·), ğ‘…
Output: Î”ğ» , ğ‘ ğ‘ğ‘Ÿğ‘’ (Â·)

1 Î”ğ» â† âˆ…;
2 for (ğ‘£ğ‘–, ğ‘£ğ‘— , ğ›¼ ) âˆˆ Î”ğº do
3

ğ‘Ÿğ‘– â† ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘– ), ğ‘Ÿ ğ‘— â† ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘— );
Î”ğ» .ğ‘ğ‘‘ğ‘‘ ( (ğ‘ ğ‘–, ğ‘  ğ‘— , ğ›¼ ) );

4
5 for ğ‘£ğ‘– âˆˆ ğ‘… do
6

for ğ‘£ğ‘— âˆˆ ğ‘ (ğ‘£ğ‘— ) do

7

8

9

10

if ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ğ‘— ) = ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘— ) or ğ‘– < ğ‘— then

Î”ğ» .ğ‘ğ‘‘ğ‘‘ ( (ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘– ), ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘— ), âˆ’ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘— ) ) );
Î”ğ» .ğ‘ğ‘‘ğ‘‘ ( (ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ğ‘– ), ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ğ‘— ), ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘— ) ) );

Î”ğ» .ğ‘ğ‘‘ğ‘‘ ( (ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘– ), ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘– ), âˆ’ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘– ) ) );
Î”ğ» .ğ‘ğ‘‘ğ‘‘ ( (ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ğ‘– ), ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ğ‘– ), ğ‘¤ (ğ‘£ğ‘–, ğ‘£ğ‘– ) ) );

11
12 for ğ‘£ğ‘– âˆˆ ğ‘… do
13
14 ğ¶ğ‘œğ‘šğ‘ğ‘Ÿğ‘’ğ‘ ğ‘  (Î”ğ» );
15 return Î”ğ» , ğ‘ ğ‘ğ‘Ÿğ‘’ (Â·);

ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ğ‘– ) â† ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ğ‘– );

either ğ‘ ğ‘ğ‘¢ğ‘Ÿ (ğ‘£ ğ‘— ) = ğ‘ ğ‘ğ‘Ÿğ‘’ (ğ‘£ ğ‘— ) or ğ‘– < ğ‘— to avoid duplicate updates (lines
5-9). Besides, it updates the self-loop for the sub-community of ğ‘£ğ‘–
(lines 10-11). Finally, it locally updates ğ‘ ğ‘ğ‘Ÿğ‘’ (Â·) to match ğ‘ ğ‘ğ‘¢ğ‘Ÿ (Â·) for
the next time step (lines 12-13), and compresses entries by summing
the weight of identical superedges in Î”ğ» (line 14).

5.4 Overall HIT-Leiden algorithm

(a) Before maintenance.

(b) After maintenance.

Figure 9: The hierarchical partitions changes of Figure 1.

Before presenting our overall HIT-Leiden algorithm, we intro-
duce an optimization technique to further improve the efficiency of
the verticesâ€™ membership update. Specifically, when a supervertex
changes its community membership, all the lower-level superver-
tices associated with it have to update their community membership.
3 and ğ‘£ 1
As shown in Figure 9, when ğ‘£ 2
4
also update their community memberships to the community con-
taining ğ‘£ 2
10. However, during the iteration process of HIT-Leiden,
a supervertex that changes its community does not automatically
trigger updates of the community memberships of its constituent
lower-level supervertices.

10 changes its community, ğ‘£ 1

To resolve the above inconsistency, we perform a post-processing
step to synchronize the community memberships across all levels,
as described in Algorithm 5. Let {ğµğ‘ƒ } denote a sequence of ğ‘ƒ sets
{ğµ1, Â· Â· Â· , ğµğ‘ƒ }, {ğ‘ ğ‘ƒ (Â·)} denote a sequence of ğ‘ƒ adajcent-level super-
vertex mappings {ğ‘ 1 (Â·), Â· Â· Â· , ğ‘ ğ‘ƒ (Â·)}, and {ğ‘“ ğ‘ƒ (Â·)} denote a sequence
of ğ‘ƒ community mappings {ğ‘“ 1 (Â·), Â· Â· Â· , ğ‘“ ğ‘ƒ (Â·)}. Note, each ğµğ‘ in
{ğµğ‘ƒ } collects supervertices at level-ğ‘ whose community member-
ships have changed, each ğ‘ ğ‘ (Â·) in {ğ‘ ğ‘ƒ (Â·)} maps from level-ğ‘ super-
vertices to their parent supervertices at level-(ğ‘ + 1), and each ğ‘“ ğ‘ (Â·)
in {ğ‘“ ğ‘ƒ (Â·)} maps from level-ğ‘ supervertices to their communities.
A supervertex is added to ğµğ‘ for one of two reasons: (1) it changes

Algorithm 5: def-update
Input: { ğ‘“ ğ‘ƒ (Â·) }, {ğ‘ ğ‘ƒ (Â·) }, {ğµğ‘ƒ }, ğ‘ƒ
Output: Updated { ğ‘“ ğ‘ƒ (Â·) }

1 for ğ‘ from ğ‘ƒ to 1 do
2

if ğ‘ â‰  ğ‘ƒ then
for ğ‘£ğ‘

ğ‘– âˆˆ ğµğ‘ do
ğ‘“ ğ‘ (ğ‘£ğ‘–

ğ‘ ) = ğ‘“ ğ‘+1 (ğ‘ ğ‘ (ğ‘£ğ‘–

ğ‘ ) );

if ğ‘ â‰  1 then
for ğ‘£ğ‘

ğ‘– âˆˆ ğµğ‘ do
ğµğ‘ âˆ’1.ğ‘ğ‘‘ğ‘‘ (ğ‘  âˆ’ğ‘ (ğ‘£ğ‘

ğ‘– ) );

3

4

5

6

7

8 return { ğ‘“ ğ‘ƒ (Â·) };

its community during inc-movement, or (2) its higher-level super-
vertex changes community. Hence, for each level ğ‘, def-update
updates each supervertex in ğµğ‘ by re-mapping its community mem-
bership of its parent using ğ‘ ğ‘ (Â·) and ğ‘“ ğ‘+1 (Â·) when ğ‘ â‰  ğ‘ƒ (lines 1-4),
and adds its constituent vertices to ğµğ‘ âˆ’1 for the next level updates
where ğ‘  âˆ’ğ‘ (Â·) is the inverse mapping of ğ‘ ğ‘ (Â·) when ğ‘ â‰  1 (lines 5-7).
This algorithm also supports updating the mappings {ğ‘”ğ‘ƒ (Â·)} from
each level supervertex to its level-ğ‘ƒ ancestor.

â€¢ Overall HIT-Leiden. After introducing all the key compo-
nents, we present our overall HIT-Leiden in Algorithm 6. The
algorithm proceeds over ğ‘ƒ hierarchical levels, where each level-ğ‘
operates on a corresponding supergraph ğºğ‘ . Besides the commu-
nity membership ğ‘“ (Â·), HIT-Leiden also maintains supergraphs
{ğº ğ‘ƒ }, community mappings {ğ‘“ ğ‘ƒ (Â·)}, sub-community mappings
ğ‘ğ‘¢ğ‘Ÿ (Â·)}, and CC-indices {Î¨ğ‘ƒ } to maintain
{ğ‘”ğ‘ƒ (Â·)}, {ğ‘ ğ‘ƒ
sub-community memberships for each level. Note, {ğ‘ ğ‘ƒ
ğ‘ğ‘Ÿğ‘’ (Â·)} are the
mappings from the previous time step, and {ğ‘ ğ‘ƒ
ğ‘ğ‘¢ğ‘Ÿ (Â·)} are the in-time
mappings to track sub-community memberships as they evolve at
the current time step.

ğ‘ğ‘Ÿğ‘’ (Â·)} and {ğ‘ ğ‘ƒ

Specifically, it initializes {ğ‘ ğ‘ƒ

ğ‘ğ‘Ÿğ‘’ (Â·)}. Given the graph
change Î”ğº, it first initializes the first-level update Î”ğº to Î”ğº 1 (line
1). It then proceeds through ğ‘ƒ iterations, each including three phases
after updating the supergraph ğºğ‘ (line 3).

ğ‘ğ‘¢ğ‘Ÿ (Â·)} = {ğ‘ ğ‘ƒ

(1) Inc-movement (line 4): it re-assigns community member-
ships of affected vertices to achieve vertex optimality, which
yields ğ‘“ ğ‘ (Â·), Î¨, ğµğ‘ , and ğ¾.

(2) Inc-refinement (line 5): it re-maps the supervertices of
split connected components in Î¨ to new sub-communities,
producing ğ‘ ğ‘

ğ‘ğ‘¢ğ‘Ÿ (Â·), Î¨, and ğ‘…ğ‘ .

(3) Inc-aggregation (line 7): it calculates the next levelâ€™s su-
ğ‘ğ‘Ÿğ‘’ (Â·) to match

peredge changes Î”ğºğ‘+1, and synchronizes ğ‘ ğ‘
ğ‘ ğ‘
ğ‘ğ‘¢ğ‘Ÿ (Â·).

After ğ‘ƒ iterations, def-update (Algorithm 5) synchronizes com-
munity mappings {ğ‘“ ğ‘ƒ (Â·)} and sub-community mappings {ğ‘”ğ‘ƒ (Â·)}
across levels (lines 8-9). The final output ğ‘“ (Â·) is set to ğ‘”1 (Â·) (line 10).
Besides, we also return {ğº ğ‘ƒ }, {ğ‘“ ğ‘ƒ (Â·)}, {ğ‘”ğ‘ƒ (Â·)}, {ğ‘ ğ‘ƒ
ğ‘ğ‘¢ğ‘Ÿ (Â·)},
and {Î¨ğ‘ƒ } for the next graph evolution (line 11).

ğ‘ğ‘Ÿğ‘’ (Â·)}, {ğ‘ ğ‘ƒ

3, ğ‘£ 1

Example 7. Consider the result in Figure 4. The graph undergoes an
edge deletion (ğ‘£ 1
5, âˆ’1) and an edge insertions (ğ‘£ 1
3, 1). Resulting
community and sub-community changes are shown in Figure 10,
with hierarchical changes in Figure 9. Take the second iteration as
an example. In inc-movement, the supervertex ğ‘£ 2
10 is reassigned to

1, ğ‘£ 1

ğ‘£!""ğ‘£!#"ğ‘£!!ğ‘£$!ğ‘£%!ğ‘£&!ğ‘£'!ğ‘£(!ğ‘£#!ğ‘£"!ğ‘£)$ğ‘£!!$ğ‘£!$$ğ‘£!*$ğ‘£!""ğ‘£!#"ğ‘£!!ğ‘£$!ğ‘£%!ğ‘£&!ğ‘£'!ğ‘£(!ğ‘£#!ğ‘£"!ğ‘£)$ğ‘£!!$ğ‘£!$$ğ‘£!*$SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

(a) Community maintain by HIT-Leiden

(b) The process of HIT-Leiden in iteration two

Figure 10: An example of HIT-Leiden

Algorithm 6: HIT-Leiden
Input: {ğº ğ‘ƒ }, Î”ğº, { ğ‘“ ğ‘ƒ (Â·) }, {ğ‘”ğ‘ƒ (Â·) },{ğ‘ ğ‘ƒ

ğ‘ğ‘Ÿğ‘’ (Â·) }, {ğ‘ ğ‘ƒ

ğ‘ğ‘¢ğ‘Ÿ (Â·) }, {Î¨ğ‘ƒ },

Output: ğ‘“ (Â·), {ğº ğ‘ƒ }, { ğ‘“ ğ‘ƒ (Â·) }, { ğ‘“ ğ‘ƒ (Â·) }, {ğ‘ ğ‘ƒ

ğ‘ğ‘Ÿğ‘’ (Â·) }, {ğ‘ ğ‘ƒ

ğ‘ğ‘¢ğ‘Ÿ (Â·) },

ğ‘ƒ, ğ›¾

{Î¨ğ‘ƒ }

1 Î”ğº 1 â† Î”ğº;
2 for ğ‘ from 1 to ğ‘ƒ do
3

4

5

6

7

ğº ğ‘ â† ğº ğ‘ âŠ• Î”ğº ğ‘ ;
ğ‘“ ğ‘ (Â·), Î¨, ğµğ‘, ğ¾ â†
inc-movement(ğº ğ‘, Î”ğº ğ‘, ğ‘“ ğ‘ (Â·), ğ‘ ğ‘
ğ‘ ğ‘
ğ‘ğ‘¢ğ‘Ÿ (Â·), Î¨, ğ‘…ğ‘ â†
inc-refinement(ğº ğ‘, ğ‘“ ğ‘ (Â·), ğ‘ ğ‘
if p < P then
Î”ğº ğ‘+1, ğ‘ ğ‘
inc-aggregation(ğº ğ‘, Î”ğº ğ‘, ğ‘ ğ‘

ğ‘ğ‘Ÿğ‘’ (Â·) â†

ğ‘ğ‘¢ğ‘Ÿ (Â·), Î¨, ğ›¾ );

ğ‘ğ‘¢ğ‘Ÿ (Â·), Î¨, ğ¾, ğ›¾ );

ğ‘ğ‘Ÿğ‘’ (Â·), ğ‘ ğ‘

ğ‘ğ‘¢ğ‘Ÿ (Â·), ğ‘…ğ‘ );

8 { ğ‘“ ğ‘ƒ (Â·) } â† def-update( { ğ‘“ ğ‘ƒ (Â·) }, {ğ‘ ğ‘ƒ
9 {ğ‘”ğ‘ƒ (Â·) } â† def-update( {ğ‘”ğ‘ƒ (Â·) }, {ğ‘ ğ‘ƒ
10 ğ‘“ (Â·) â† ğ‘”1 (Â·);
11 return ğ‘“ (Â·), {ğº ğ‘ƒ }, { ğ‘“ ğ‘ƒ (Â·) }, {ğ‘”ğ‘ƒ (Â·) }, {ğ‘ ğ‘ƒ

ğ‘ğ‘¢ğ‘Ÿ (Â·) }, {ğµğ‘ƒ }, ğ‘ƒ );
ğ‘ğ‘¢ğ‘Ÿ (Â·) }, {ğ‘…ğ‘ƒ }, ğ‘ƒ );

ğ‘ğ‘Ÿğ‘’ (Â·) }, {ğ‘ ğ‘ƒ

ğ‘ğ‘¢ğ‘Ÿ (Â·) },

{Î¨ğ‘ƒ };

ğ‘£ 3
15 due to disconnection, and migrates from community ğ¶2 to ğ¶1. In
inc-refinement, ğ‘£ 2
13. Then, inc-aggregation
calculates superedge changes for level-3, including edge insertion
(ğ‘£ 3
14, ğ‘£ 3

13, 2) and edge deletions (ğ‘£ 3

10 is merged into ğ‘£ 3

14, âˆ’2).

13, ğ‘£ 3

â€¢ Complexity analysis. We now analyze the time complexity
of HIT-Leiden over ğ‘ƒ iterations. Let Î“ğ‘ denote the set of superver-
tices involved in superedge changes, and let Î›ğ‘ track the superver-
tices that change their communities or sub-communities at level-ğ‘.
Therefore, for each level-ğ‘, inc-movement, inc-refinement, and
inc-aggregation complete in ğ‘‚ (|ğ‘2 (Î“ğ‘ )|+|ğ‘2 (Î›ğ‘ )|), ğ‘‚ (|ğ‘ (Î“ğ‘ )|+
|ğ‘ (Î›ğ‘ )|), and ğ‘‚ (|ğ‘ (Î“ğ‘ )| + |ğ‘ (Î›ğ‘ )|), respectively. Besides, the time
)ï¸‚. Hence, the total time cost of
ğ‘=1 |Î›ğ‘ |
cost of def-update is ğ‘‚
HIT-Leiden is ğ‘‚ (âˆ‘ï¸ğ‘ƒ
ğ‘=1 (|ğ‘2 (Î“ğ‘ )|+|ğ‘2 (Î›ğ‘ )|)) = ğ‘‚ (|ğ‘2 (CHANGED)|+
|ğ‘2 (AFF)|), as analyzed in Section 4.2. As a result, our HIT-Leiden
is bounded relative to Leiden.

(ï¸‚âˆ‘ï¸ğ‘ƒ

6 Experiments
We now present our experimental results. Section 6.1 introduces the
experimental setup. Section 6.2 and 6.3 evaluate the effectiveness
and efficiency of HIT-Leiden, respectively.

|ğ¸|

Abbr.

Table 3: Datasets used in our experiments.
|ğ‘‰ |
Dataset
dblp-coauthor
yahoo-song
sx-stackoverflow
it-2004
risk

Timestamp
Yes
Yes
Yes
No
Yes

1.8M
1.6M
2.6M
41.2M
201.0M

29.4M
256.8M
63.4M
1.0B
4.0B

DC
YS
SS
IT
RS

6.1 Setup
Datasets. We use four real-world dynamic datasets, including dblp-
coauthor1 (academic collaboration), yahoo-song1 (user-song inter-
actions), sx-stackoverflow2 (developer Q&A), and risk (financial
transactions) provided by ByteDance. All these dynamic edges are
associated with real timestamps. We also use one static dataset it-
20043 (a large-scale web graph), but randomly insert or delete some
edges to simulate a dynamic graph. All the graphs are treated as
undirected graphs. For each real-world dynamic graph, we collect a
sequence of batch updates by sorting the edges in ascending order
of their timestamps; for it-2004, which lacks timestamps, we ran-
domly shuffle its edge order. Table 3 summarizes the key statistics
of the above datasets.

Algorithms. We test the following maintenance algorithms:

â€¢ ST-Leiden: A naive baseline that executes the static Leiden

algorithm from scratch when the graph changes.

â€¢ ND-Leiden: A simple maintenance algorithm in [70], which
processes all vertices during the movement phase, initialized
with previous community memberships.

â€¢ DS-Leiden: A maintenance algorithm based on [70], which
uses the delta-screening technique [97] to restrict the num-
ber of vertices considered in the movement phase.

â€¢ DF-Leiden: An advanced maintenance algorithm from [70],
which adopts the dynamic frontier approach [69] to support
localized updates.

â€¢ HIT-Leiden: Our proposed method.

Dynamic graph settings. As the temporal span varies across
datasets (e.g., 62 years for dblp-coauthor versus 8 years for sx-
stackoverflow), we apply a sliding edge window, avoiding reliance
on fixed valid time intervals that are hard to standardize. Initially,
we construct a static graph using the first 80% of edges. Then, we se-
lect a window size ğ‘ âˆˆ {10, 102, 103, 104, 105}, denoting the number
of updated edges in an updated batch. Next, we slide this window
ğ‘Ÿ = 9 times, so we update 9 batches of edges for each dataset. Note
that by default, we set ğ‘ = 103.

1http://konect.cc/networks/
2https://snap.stanford.edu/data/
3https://networkrepository.com/

ğ‘£!"ğ‘£#$"ğ‘£##"ğ‘£#""ğ‘£#%&ğ‘£#&&ğ‘£"#ğ‘£##ğ‘£%#ğ‘£&#ğ‘£'#ğ‘£(#ğ‘£)#ğ‘£*#HIT-Leidenğ‘£!"ğ‘£##"ğ‘£#""ğ‘£#%&ğ‘£#&&ğ‘£"#ğ‘£##ğ‘£#$"ğ‘£%#ğ‘£&#ğ‘£'#ğ‘£(#ğ‘£)#ğ‘£*#ğ¶#ğ¶"ğ¶#ğ¶"Updateâ€¦ğ‘£!"ğ‘£#$$ğ‘£#%"ğ‘£##"ğ‘£#""ğ‘£#&$ğ‘£!"ğ‘£#$$ğ‘£##"ğ‘£#""ğ‘£#&$ğ‘£#%"ğ‘£#'$ğ‘£!"ğ‘£#$$ğ‘£##"ğ‘£#""ğ‘£#&$ğ‘£#%"Inc-movementInc-aggregationâ€¦Inc-refinementğ¶#ğ¶"ğ¶#ğ¶"ğ¶#ğ¶"Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

All the algorithms are implemented in C++ and compiled with
the gcc 8.3.0 compiler using the -O0 optimization level. We set ğ›¾ = 1
and use ğ‘ƒ = 10 iterations. Before running the Leiden community
maintenance algorithms, we obtain the communities by running
the Leiden algorithm, and HIT-Leiden requires an additional pro-
cedure to build auxiliary structures. Due to the limited number of
iterations, the community structure has not fully converged, so the
maintenance algorithms usually take more time in the first two
batches than in other batches. Therefore, we exclude the first two
batches from efficiency evaluations. Experiments are conducted on
a Linux server running Debian 5.4.56, equipped with an Intel(R)
Xeon(R) Platinum 8336C CPU @ 2.30GHz and 2.0 TB of RAM.

6.2 Effectiveness evaluation
To evaluate the effectiveness of different maintenance algorithms,
we compare the modularity value and proportion of subpartition
ğ›¾-dense communities for their returned communities. We also eval-
uate the long-term effectiveness of community maintenance and
present a case study.

â€¢ Modularity. Figure 11 depicts the average modularity values
of all the maintenance algorithms, where the batch size ranges from
10 to 105. Figure 12 depicts the modularity value across all the 9
batches, where the batch size is fixed as 1,000. Across all datasets,
the expected fluctuation in modularity for ST-Leiden is around
0.02 due to its inherent randomness. These maintenance algorithms
achieve equivalent quality in modularity, since the difference in
their modularity values is within 0.01. Overall, our HIT-Leiden
achieves comparable modularity with other methods.

â€¢ Proportion of subpartition ğ›¾-density. After running HIT-
Leiden, for each returned community, we try to re-find its ğ›¾-order
such that any intermediate vertex set in the ğ›¾-order is locally opti-
mized, according to Definition 9. If we can find a valid ğ›¾-order for
a community, we classify it as a subpartition ğ›¾-dense community.
We report the proportion of subpartition ğ›¾-dense communities in
Figure 13. The proportions of subpartition ğ›¾-dense communities
among these Leiden algorithms are almost 1, and they are within
the expected fluctuation (around 0.0001) caused by the inherent
randomness of the measure method. Thus, HIT-Leiden achieves a
comparable percentage of subpartition ğ›¾-density with others.

â€¢ Long-term effectiveness. To demonstrate the long-term ef-
fectiveness of maintaining communities, we enlarge the number ğ‘Ÿ
of batches from 9 to 999 and set ğ‘ = 10, 000. Figure 14(a)-(c) presents
the modularity, proportion of subpartition ğ›¾-dense communities,
and runtime on the sx-stackoverflow dataset. We observe that incre-
mental Leiden algorithms exhibit higher stability than ST-Leiden
in modularity since they use previous community memberships,
and HIT-Leiden is faster than other algorithms.

â€¢ A case study. Our HIT-Leiden has been deployed at ByteDance
to support several real applications. Here, we briefly introduce the
application of Graph-RAG. To augment the LLM generation for
answering a question, people often retrieve relevant information
from an external corpus. To facilitate retrieval, Graph-RAG builds
an offline index: It first builds a graph for the corpus, then clus-
ters the graph hierarchically using Leiden, and finally associates
a summary for each community, which is generated by an LLM
with some token cost. In practice, since the underlying corpus often

changes, the communities and their summaries need to be updated
as well. Our HIT-Leiden can not only dynamically update the com-
munities efficiently, but also save the token cost since we only need
to regenerate the summaries for the updated communities.

To experiment, we use the HotpotQA [95] dataset, which con-
tains Wikipedia-based question-answer (QA) pairs. We randomly
select 9,500 articles to build the initial graph, and insert 9 batches
of new articles, each with 5 articles. The LLM we use is doubao-
1.5-pro-32k. To support a dynamic corpus, we adapt the static
Graph-RAG method by updating communities using ST-Leiden
and HIT-Leiden, respectively. These two RAG methods are denoted
by ST-Leiden-RAG and HIT-Leiden-RAG, respectively. Note that
ND-Leiden, DS-Leiden, and DF-Leiden are not fit to maintain the
hierarchical communities of Graph-RAG since they lack hierarchi-
cal maintenance. We report their runtime, token cost, and accuracy
in Figure 14(d)-(f). Clearly, HIT-Leiden-RAG is 56.1Ã— faster than
ST-Leiden-RAG. Moreover, it significantly reduces the summary
token cost while preserving downstream QA accuracy, since its
token cost is only 0.8% of the token cost of ST-Leiden-RAG. Hence,
HIT-Leiden is effective for supporting Graph-RAG on a dynamic
corpus.

6.3 Efficiency evaluation
In this section, we first present the overall efficiency results, then
analyze the time cost of each component, and finally evaluate the
effects of some hyperparameters.

â€¢ Overall results. Figure 15 presents the overall efficiency re-
sults where ğ‘ is set to its default value 1, 000. Clearly, HIT-Leiden
achieves the best efficiency on datasets, especially on the it-2004
dataset, since it is up to three orders of magnitude faster than the
state-of-the-art algorithms. That is mainly because the ratio of
updated edges to total edges in it-2004 is larger than those in
dblp-coauthor, yahoo-song, and sx-stackoverflow.

â€¢ Time cost of different components in HIT-Leiden. There
are three key components, i.e., inc-movement, inc-refine, and
inc-aggregation, in HIT-Leiden. We evaluate the proportion of
time cost for each component and present the results in Figure 16.
Note that some operations (e.g., def-update in HIT-Leiden) may
not be included by the above three components, so we put them into
the "Others" component. Notably, in HIT-Leiden, the refinement
phase contributes minimally to the overall runtime. Besides, the
combined proportion of time spent in its movement and aggregation
phase is comparable to that of other algorithms. Inc-movement,
inc-refinement, and inc-aggregation consistently outperform
their counterparts in other algorithms across all datasets, achieving
lower absolute runtime costs according to Figure 15.

â€¢ Effect of ğ‘. We vary the batch size ğ‘ âˆˆ {10, 102, 103, 104, 105}
and report the efficiency in Figure 17. We see that HIT-Leiden is
up to five orders of magnitude faster than other algorithms. Also, it
exhibits a notable increase as ğ‘ becomes smaller because it is a rela-
tively bounded algorithm. In contrast, ND-Leiden, DS-Leiden, and
DF-Leiden still need to process the entire graph when processing
a new batch.

â€¢ Effect of ğ‘Ÿ . Recall that after fixing the batch size ğ‘, we update
the graph for ğ‘Ÿ batches. Figure 18 shows the efficiency, where ğ‘ is

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

y
t
i
r
a
l
u
d
o
M

0.78

0.77

0.76

0.75

y
t
i
r
a
l
u
d
o
M

0.78

0.77

0.76

0.75

0.74

0.370

0.365

0.360

101 102 103 104 105
batch size
(a) DC

ST-Leiden

ND-Leiden
0.455

DS-Leiden

DF-Leiden
0.973

0.450

0.972

HIT-Leiden

0.445

0.971

101 102 103 104 105
batch size
(b) YS

101 102 103 104 105
batch size
(c) SS
Figure 11: Modularity values on dynamic graphs.

101 102 103 104 105
batch size
(d) IT

ST-Leiden

0.370

0.365

ND-Leiden
0.455

DS-Leiden

DF-Leiden
0.973

0.450

0.972

HIT-Leiden

0 1 2 3 4 5 6 7 8 9
batch
(a) DC

0.360

0.445

0.971

0 1 2 3 4 5 6 7 8 9
batch
(b) YS

0 1 2 3 4 5 6 7 8 9
batch
(c) SS
Figure 12: Modularity changes w.r.t. the number of update batches.

0 1 2 3 4 5 6 7 8 9
batch
(d) IT

0.365

0.360

0.355

101 102 103 104 105
batch size
(e) RS

0.365

0.360

0.355

0 1 2 3 4 5 6 7 8 9
batch
(e) RS

ST-Leiden
DF-Leiden

ND-Leiden
HIT-Leiden

DS-Leiden

y
t
i
n
u
m
m
o
c
%

100

99

98

97

)
s

m

(

e
m

i
t
n
u
R

108

105

102

ST-Leiden
DF-Leiden

ND-Leiden
HIT-Leiden

DS-Leiden

DC

YS

SS

IT

RS

Figure 13: Percentage of subpartition ğ›¾-dense communities.

ND-Leiden
HIT-Leiden

DS-Leiden
ST-Leiden-RAG

ST-Leiden
DF-Leiden
HIT-Leiden-RAG
0.5
0.48
0.46
0.44
0.42
0.4

0

250

500
batch

y
t
i
n
u
m
m
o
C
%

100

99.8

99.6

750

999

0

250

105
104
103
102
101

109
108
107
106
105
104

(a) Modularity

750

999

0

250

500
batch
(c) Runtime

0 1 2 3 4 5 6 7 8 9
batch

(e) Token cost

750

999

500
batch

(b) Subpartition ğ›¾ -density

)
s

m

(

e
m

i
t
n
u
R

108

107

106

105

y
c
a
r
u
c
c
A

0.6
0.58
0.56
0.54
0.52
0.5

0 1 2 3 4 5 6 7 8 9
batch
(d) Runtime

0 1 2 3 4 5 6 7 8 9
batch
(f) Accuracy

y
t
i
r
a
l
u
d
o
M

)
s

m

(

e
m

i
t
n
u
R

s
n
e
k
o
t

f
o
#

Figure 14: Subfigures (a)â€“(c) show the effectiveness of HIT-
Leiden over 999 update batches, and subfigures (d)â€“(f)
compare ST-Leiden-RAG and HIT-Leiden-RAG over 9 update
batches.

DC

YS

SS

IT

RS

Figure 15: Efficiency of all Leiden algorithms on all datasets.
fixed as 1,000, but ğ‘Ÿ ranges from 1 to 9. We observe that the incre-
mental speedup is limited in the first few batches because ğ‘ƒ = 10 is
small, and additional iterations may slightly improve the commu-
nity membership. As a result, all the maintenance algorithms often
require more time for the second batch to adjust the community
structure. Once high-quality community structure is established,
the speedup becomes significant. In addition, HIT-Leiden incurs a
slightly higher runtime to record more information and construct
the CC-index.

7 Conclusions
In this paper, we develop an efficient algorithm for maintaining Lei-
den communities in a dynamic graph. We first theoretically analyze
the boundedness of existing algorithms and how supervertex behav-
iors affect community membership under graph update. Building
on these analyses, we further develop a relative boundedness algo-
rithm, called HIT-Leiden, which consists of three key components,
i.e., inc-movement, inc-refinement, and inc-aggregation. Ex-
tensive experiments on five real-world dynamic graphs show that
HIT-Leiden not only preserves the properties of Leiden and achieves
comparable modularity quality with Leiden, but also runs faster
than state-of-the-art competitors. In future work, we will extend
our algorithm to handle directed graphs and also evaluate it in a
distributed environment.

References

[1] 2020. A single-cell transcriptomic atlas characterizes ageing tissues in the mouse.

Nature 583, 7817 (2020), 590â€“595.

[2] Edo M Airoldi, David Blei, Stephen Fienberg, and Eric Xing. 2008. Mixed
membership stochastic blockmodels. Advances in neural information processing
systems 21 (2008).

)

%

(
n
o
i
t
r
o
p
o
r
p
e
m
T

i

100
80
60
40
20
0

105

104

103

102

)
s

m

(

e
m

i
t
n
u
R

)
s

m

(

e
m

i
t
n
u
R

105

104

103

102

Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Inc-movement

Inc-refinement

Inc-aggregation

Others

100
80
60
40
20
0

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

100
80
60
40
20
0

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

100
80
60
40
20
0

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

100
80
60
40
20
0

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

(a) DC

(c) SS
Figure 16: Proportion of time cost of each component for the Leiden algorithms on all datasets.

(b) YS

(d) IT

(e) RS

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

101 102 103 104 105
batch size
(a) DC

106
105
104
103
102
101

107

105

103

101 102 103 104 105
batch size
(b) YS

101 102 103 104 105
batch size
(c) SS
Figure 17: Runtime on dynamic graphs.

101 102 103 104 105
batch size
(d) IT

ST-Leiden

ND-Leiden

DS-Leiden

DF-Leiden

HIT-Leiden

105

103

101

106

104

102

100

107

105

103

101

107

105

103

101

107

105

103

101 102 103 104 105
batch size
(e) RS

108
107
106
105
104

0 1 2 3 4 5 6 7 8 9
batch
(e) RS

0 1 2 3 4 5 6 7 8 9
batch
(a) DC

0 1 2 3 4 5 6 7 8 9
batch
(b) YS

0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8 9
batch
batch
(d) IT
(c) SS
Figure 18: Runtime w.r.t. the number of update batches.

[3] Arash A Amini, Aiyou Chen, Peter J Bickel, and Elizaveta Levina. 2013. Pseudo-
likelihood methods for community detection in large sparse networks. (2013).
[4] Abdelouahab Amira, Abdelouahid Derhab, Elmouatez Billah Karbab, and Omar
Nouali. 2023. A survey of malware analysis using community detection algo-
rithms. Comput. Surveys 56, 2 (2023), 1â€“29.

[5] LN Fred Ana and Anil K Jain. 2003. Robust data clustering. In 2003 IEEE Computer
Society Conference on Computer Vision and Pattern Recognition, 2003. Proceedings.,
Vol. 2. IEEE, IIâ€“II.

[6] Thomas Aynaud and Jean-Loup Guillaume. 2010. Static community detection
algorithms for evolving networks. In 8th international symposium on modeling
and optimization in mobile, ad hoc, and wireless networks. IEEE, 513â€“519.
[7] Thomas Aynaud and Jean-Loup Guillaume. 2011. Multi-step community detec-
tion and hierarchical time segmentation in evolving networks. In Proceedings of
the 5th SNA-KDD workshop, Vol. 11.

[8] Trygve E Bakken, Nikolas L Jorstad, Qiwen Hu, Blue B Lake, Wei Tian, Brian E
Kalmbach, Megan Crow, Rebecca D Hodge, Fenna M Krienen, Staci A Sorensen,
et al. 2021. Comparative cellular analysis of motor cortex in human, marmoset
and mouse. Nature 598, 7879 (2021), 111â€“119.

[9] Vandana Bhatia and Rinkle Rani. 2018. Dfuzzy: a deep learning-based fuzzy
clustering model for large graphs. Knowledge and Information Systems 57 (2018),
159â€“181.

[10] Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefeb-
vre. 2008. Fast unfolding of communities in large networks. Journal of statistical
mechanics: theory and experiment 2008, 10 (2008), P10008.

[11] Stefan Boettcher and Allon G Percus. 2002. Optimization with extremal dynam-

ics. complexity 8, 2 (2002), 57â€“62.

[12] Biao Cai, Yanpeng Wang, Lina Zeng, Yanmei Hu, and Hongjun Li. 2020. Edge
classification based on convolutional neural networks for community detection
in complex network. Physica A: statistical mechanics and its applications 556
(2020), 124826.

[13] Tanmoy Chakraborty, Ayushi Dalmia, Animesh Mukherjee, and Niloy Ganguly.
2017. Metrics for community analysis: A survey. ACM Computing Surveys
(CSUR) 50, 4 (2017), 1â€“37.

[14] Qing Chen, Sven Helmer, Oded Lachish, and Michael Bohlen. 2022. Dynamic
spanning trees for connectivity queries on fully-dynamic undirected graphs.
(2022).

[15] Jiafeng Cheng, Qianqian Wang, Zhiqiang Tao, Deyan Xie, and Quanxue Gao.
2021. Multi-view attribute graph convolution networks for clustering. In Proceed-
ings of the twenty-ninth international conference on international joint conferences
on artificial intelligence. 2973â€“2979.

[16] Yun Chi, Xiaodan Song, Dengyong Zhou, Koji Hino, and Belle L Tseng. 2007.
Evolutionary spectral clustering by incorporating temporal smoothness. In
Proceedings of the 13th ACM SIGKDD international conference on Knowledge
discovery and data mining. 153â€“162.

[17] Yun Chi, Xiaodan Song, Dengyong Zhou, Koji Hino, and Belle L Tseng. 2009.
On evolutionary spectral clustering. ACM Transactions on Knowledge Discovery
from Data (TKDD) 3, 4 (2009), 1â€“30.

[18] Wen Haw Chong and Loo Nin Teow. 2013. An incremental batch technique
for community detection. In Proceedings of the 16th international conference on
information fusion. IEEE, 750â€“757.

[19] Aaron Clauset, Mark EJ Newman, and Cristopher Moore. 2004. Finding commu-
nity structure in very large networks. Physical Review Eâ€”Statistical, Nonlinear,
and Soft Matter Physics 70, 6 (2004), 066111.

[20] MÃ¡rio Cordeiro, Rui Portocarrero Sarmento, and Joao Gama. 2016. Dynamic com-
munity detection in evolving networks using locality modularity optimization.
Social Network Analysis and Mining 6 (2016), 1â€“20.

[21] Ganqu Cui, Jie Zhou, Cheng Yang, and Zhiyuan Liu. 2020. Adaptive graph
encoder for attributed graph embedding. In Proceedings of the 26th ACM SIGKDD
international conference on knowledge discovery & data mining. 976â€“985.
[22] Siemon C de Lange, Marcel A de Reus, and Martijn P van den Heuvel. 2014. The
Laplacian spectrum of neural networks. Frontiers in computational neuroscience
7 (2014), 189.

[23] Martin Ester, Hans-Peter Kriegel, JÃ¶rg Sander, Xiaowei Xu, et al. 1996. A density-
based algorithm for discovering clusters in large spatial databases with noise.
In kdd, Vol. 96. 226â€“231.

[24] Shaohua Fan, Xiao Wang, Chuan Shi, Emiao Lu, Ken Lin, and Bai Wang. 2020.
One2multi graph autoencoder for multi-view graph clustering. In proceedings
of the web conference 2020. 3070â€“3076.

[25] Wenfei Fan, Chunming Hu, and Chao Tian. 2017. Incremental graph compu-
tations: Doable and undoable. In Proceedings of the 2017 ACM International
Conference on Management of Data. 155â€“169.

[26] Xinyu Fu, Jiani Zhang, Ziqiao Meng, and Irwin King. 2020. Magnn: Metap-
ath aggregated graph neural network for heterogeneous graph embedding. In
Proceedings of the web conference 2020. 2331â€“2341.

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

[27] LÃ¡szlÃ³ GadÃ¡r and JÃ¡nos Abonyi. 2024. Explainable prediction of node labels
in multilayer networks: a case study of turnover prediction in organizations.
Scientific Reports 14, 1 (2024), 9036.

[28] Michael S Haney, RÃ³bert PÃ¡lovics, Christy Nicole Munson, Chris Long, Pa-
trik K Johansson, Oscar Yip, Wentao Dong, Eshaan Rawat, Elizabeth West,
Johannes CM Schlachetzki, et al. 2024. APOE4/4 is linked to damaging lipid
droplets in Alzheimerâ€™s disease microglia. Nature 628, 8006 (2024), 154â€“161.
[29] Paul W Holland, Kathryn Blackmond Laskey, and Samuel Leinhardt. 1983. Sto-

chastic blockmodels: First steps. Social networks 5, 2 (1983), 109â€“137.

[30] Jacob Holm, Kristian De Lichtenberg, and Mikkel Thorup. 2001. Poly-logarithmic
deterministic fully-dynamic algorithms for connectivity, minimum spanning
tree, 2-edge, and biconnectivity. Journal of the ACM (JACM) 48, 4 (2001), 723â€“
760.

[31] Ruiqi Hu, Shirui Pan, Guodong Long, Qinghua Lu, Liming Zhu, and Jing Jiang.
2020. Going deep: Graph convolutional ladder-shape networks. In Proceedings
of the AAAI Conference on Artificial Intelligence, Vol. 34. 2838â€“2845.

[32] Xiao Huang, Jundong Li, and Xia Hu. 2017. Accelerated attributed network
embedding. In Proceedings of the 2017 SIAM international conference on data
mining. SIAM, 633â€“641.

[33] Yuting Jia, Qinqin Zhang, Weinan Zhang, and Xinbing Wang. 2019. Commu-
nitygan: Community detection with generative adversarial nets. In The world
wide web conference. 784â€“794.

[34] Baoyu Jing, Chanyoung Park, and Hanghang Tong. 2021. Hdmi: High-order
deep multiplex infomax. In Proceedings of the web conference 2021. 2414â€“2424.
[35] Ravi Kannan, Santosh Vempala, and Adrian Vetta. 2004. On clusterings: Good,

bad and spectral. Journal of the ACM (JACM) 51, 3 (2004), 497â€“515.

[36] Brian Karrer and Mark EJ Newman. 2011. Stochastic blockmodels and commu-
nity structure in networks. Physical Review Eâ€”Statistical, Nonlinear, and Soft
Matter Physics 83, 1 (2011), 016107.

[37] Scott Kirkpatrick, C Daniel Gelatt Jr, and Mario P Vecchi. 1983. Optimization

by simulated annealing. science 220, 4598 (1983), 671â€“680.

[38] Sadamori Kojaku, Giacomo Livan, and Naoki Masuda. 2021. Detecting anoma-
lous citation groups in journal networks. Scientific Reports 11, 1 (2021), 14524.
[39] Andrea Lancichinetti and Santo Fortunato. 2009. Community detection algo-
rithms: a comparative analysis. Physical Review Eâ€”Statistical, Nonlinear, and
Soft Matter Physics 80, 5 (2009), 056117.

[40] Ron Levie, Federico Monti, Xavier Bresson, and Michael M Bronstein. 2018. Cay-
leynets: Graph convolutional neural networks with complex rational spectral
filters. IEEE Transactions on Signal Processing 67, 1 (2018), 97â€“109.

[41] Bentian Li, Dechang Pi, Yunxia Lin, and Lin Cui. 2021. DNC: A deep neural
network-based clustering-oriented network embedding algorithm. Journal of
Network and Computer Applications 173 (2021), 102854.

[42] Zhangtao Li and Jing Liu. 2016. A multi-agent genetic algorithm for commu-
nity detection in complex networks. Physica A: Statistical Mechanics and its
Applications 449 (2016), 336â€“347.

[43] Xujian Liang and Zhaoquan Gu. 2025. Fast think-on-graph: Wider, deeper and
faster reasoning of large language model on knowledge graph. In Proceedings of
the AAAI Conference on Artificial Intelligence, Vol. 39. 24558â€“24566.

[44] Chunxu Lin, YiXiang Fang, Yumao Xie, Yongming Hu, Yingqian Hu, and Chen
Cheng. 2025. Efficient Maintenance of Leiden Communities in Large Dynamic
Graphs (full version). https://anonymous.4open.science/r/HIT_Leiden-2DC1.
[45] Yu-Ru Lin, Yun Chi, Shenghuo Zhu, Hari Sundaram, and Belle L Tseng. 2008.
Facetnet: a framework for analyzing communities and their evolutions in dy-
namic networks. In Proceedings of the 17th international conference on World
Wide Web. 685â€“694.

[46] Rik GH Lindeboom, Kaylee B Worlock, Lisa M Dratva, Masahiro Yoshida, David
Scobie, Helen R Wagstaffe, Laura Richardson, Anna Wilbrey-Clark, Josephine L
Barnes, Lorenz Kretschmer, et al. 2024. Human SARS-CoV-2 challenge uncovers
local and systemic response dynamics. Nature 631, 8019 (2024), 189â€“198.
[47] Monika LitviÅˆukovÃ¡, Carlos Talavera-LÃ³pez, Henrike Maatz, Daniel Reichart,
Catherine L Worth, Eric L Lindberg, Masatoshi Kanda, Krzysztof Polanski,
Matthias Heinig, Michael Lee, et al. 2020. Cells of the adult human heart. Nature
588, 7838 (2020), 466â€“472.

[48] Fanzhen Liu, Zhao Li, Baokun Wang, Jia Wu, Jian Yang, Jiaming Huang, Yiqing
Zhang, Weiqiang Wang, Shan Xue, Surya Nepal, et al. 2022. eRiskCom: an e-
commerce risky community detection platform. The VLDB Journal 31, 5 (2022),
1085â€“1101.

[49] Fanzhen Liu, Jia Wu, Chuan Zhou, and Jian Yang. 2019. Evolutionary community
detection in dynamic social networks. In 2019 International Joint Conference on
Neural Networks (IJCNN). IEEE, 1â€“7.

[50] Yanbei Liu, Xiao Wang, Shu Wu, and Zhitao Xiao. 2020. Independence promoted
graph disentangled networks. In Proceedings of the AAAI Conference on Artificial
Intelligence, Vol. 34. 4916â€“4923.

[51] Linhao Luo, Yixiang Fang, Xin Cao, Xiaofeng Zhang, and Wenjie Zhang. 2021.
Detecting communities from heterogeneous graphs: A context path-based graph
neural network model. In Proceedings of the 30th ACM international conference
on information & knowledge management. 1170â€“1180.

[52] Aaron F McDaid, Derek Greene, and Neil Hurley. 2011. Normalized mutual
information to evaluate overlapping community finding algorithms. arXiv
preprint arXiv:1110.2515 (2011).

[53] Xiangfeng Meng, Yunhai Tong, Xinhai Liu, Shuai Zhao, Xianglin Yang, and
Shaohua Tan. 2016. A novel dynamic community detection algorithm based on
modularity optimization. In 2016 7th IEEE international conference on software
engineering and service science (ICSESS). IEEE, 72â€“75.

[54] Microsoft. 2025. GraphRAG: A Structured, Hierarchical Approach to Retrieval
Augmented Generation. https://microsoft.github.io/graphrag/. Accessed: 2025-
03-31.

[55] Ida Momennejad, Hosein Hasanbeig, Felipe Vieira Frujeri, WA Redmond, Hiteshi
Sharma, Robert Ness, Nebojsa Jojic, Hamid Palangi, and Jonathan Larson. [n. d.].
Evaluating Cognitive Maps and Planning in Large Language Models with Co-
gEval (Supplementary Materials). ([n. d.]).

[56] Mark EJ Newman. 2004. Fast algorithm for detecting community structure in
networks. Physical Review Eâ€”Statistical, Nonlinear, and Soft Matter Physics 69, 6
(2004), 066133.

[57] Mark EJ Newman. 2006. Finding community structure in networks using the
eigenvectors of matrices. Physical Review Eâ€”Statistical, Nonlinear, and Soft
Matter Physics 74, 3 (2006), 036104.

[58] Mark EJ Newman. 2006. Modularity and community structure in networks.
Proceedings of the national academy of sciences 103, 23 (2006), 8577â€“8582.
[59] Mark EJ Newman. 2013. Spectral methods for community detection and graph
partitioning. Physical Review Eâ€”Statistical, Nonlinear, and Soft Matter Physics
88, 4 (2013), 042822.

[60] Mark EJ Newman and Michelle Girvan. 2004. Finding and evaluating community

structure in networks. Physical review E 69, 2 (2004), 026113.

[61] Nam P Nguyen, Thang N Dinh, Sindhura Tokala, and My T Thai. 2011. Overlap-
ping communities in dynamic networks: their detection and mobile applications.
In Proceedings of the 17th annual international conference on Mobile computing
and networking. 85â€“96.

[62] Nam P Nguyen, Thang N Dinh, Ying Xuan, and My T Thai. 2011. Adaptive
algorithms for detecting community structure in dynamic social networks. In
2011 Proceedings IEEE INFOCOM. IEEE, 2282â€“2290.

[63] Alexandru Oarga, Matthew Hart, Andres M Bran, Magdalena Lederbauer, and
Philippe Schwaller. 2024. Scientific knowledge graph and ontology generation
using open large language models. In AI for Accelerated Materials Design-NeurIPS
2024.

[64] Shashank Pandit, Duen Horng Chau, Samuel Wang, and Christos Faloutsos.
2007. Netprobe: a fast and scalable system for fraud detection in online auction
networks. In Proceedings of the 16th international conference on World Wide Web.
201â€“210.

[65] Songtao Peng, Jiaqi Nie, Xincheng Shu, Zhongyuan Ruan, Lei Wang, Yunxuan
Sheng, and Qi Xuan. 2022. A multi-view framework for BGP anomaly detection
via graph attention network. Computer Networks 214 (2022), 109129.

[66] Ganesan Ramalingam and Thomas Reps. 1996. On the computational complexity
of dynamic graph problems. Theoretical Computer Science 158, 1-2 (1996), 233â€“
277.

[67] JÃ¶rg Reichardt and Stefan Bornholdt. 2006. Statistical mechanics of community
detection. Physical Review Eâ€”Statistical, Nonlinear, and Soft Matter Physics 74, 1
(2006), 016110.

[68] Boyu Ruan, Junhao Gan, Hao Wu, and Anthony Wirth. 2021. Dynamic structural
clustering on graphs. In Proceedings of the 2021 International Conference on
Management of Data. 1491â€“1503.

[69] Subhajit Sahu. 2024. DF Louvain: Fast Incrementally Expanding Approach for
Community Detection on Dynamic Graphs. arXiv preprint arXiv:2404.19634
(2024).

[70] Subhajit Sahu. 2024. A Starting Point for Dynamic Community Detection with

Leiden Algorithm. arXiv preprint arXiv:2405.11658 (2024).

[71] Subhajit Sahu, Kishore Kothapalli, and Dip Sankar Banerjee. 2024. Fast Leiden
Algorithm for Community Detection in Shared Memory Setting. In Proceedings
of the 53rd International Conference on Parallel Processing. 11â€“20.

[72] Arindam Sarkar, Nikhil Mehta, and Piyush Rai. 2020. Graph representation
learning via ladder gamma variational autoencoders. In Proceedings of the AAAI
Conference on Artificial Intelligence, Vol. 34. 5604â€“5611.

[73] Akrati Saxena, Yulong Pei, Jan Veldsink, Werner van Ipenburg, George Fletcher,
and Mykola Pechenizkiy. 2021. The banking transactions dataset and its com-
parative analysis with scale-free networks. In Proceedings of the 2021 IEEE/ACM
International Conference on Advances in Social Networks Analysis and Mining.
283â€“296.

[74] Jiaxing Shang, Lianchen Liu, Xin Li, Feng Xie, and Cheng Wu. 2016. Targeted
revision: A learning-based approach for incremental community detection in
dynamic networks. Physica A: Statistical Mechanics and its Applications 443
(2016), 70â€“85.

[75] Jiaxing Shang, Lianchen Liu, Feng Xie, Zhen Chen, Jiajia Miao, Xuelin Fang,
and Cheng Wu. 2014. A real-time detecting algorithm for tracking community
structure of dynamic networks. arXiv preprint arXiv:1407.2683 (2014).

Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

[76] Oleksandr Shchur and Stephan GÃ¼nnemann. 2019. Overlapping community
detection with graph neural networks. arXiv preprint arXiv:1909.12201 (2019).
[77] Stanislav Sobolevsky, Riccardo Campari, Alexander Belyi, and Carlo Ratti. 2014.
General optimization technique for high-quality community detection in com-
plex networks. Physical Review E 90, 1 (2014), 012811.

[78] Xing Su, Shan Xue, Fanzhen Liu, Jia Wu, Jian Yang, Chuan Zhou, Wenbin Hu,
Cecile Paris, Surya Nepal, Di Jin, et al. 2022. A comprehensive survey on
community detection with deep learning. IEEE transactions on neural networks
and learning systems 35, 4 (2022), 4682â€“4702.

[79] Tencent. 2019. Tencent Graph Computing (TGraph) Officially Open Sourced
High-Performance Graph Computing Framework: Plato. Accessed: 2025-04-17.
[80] Vincent A Traag, Ludo Waltman, and Nees Jan Van Eck. 2019. From Louvain to
Leiden: guaranteeing well-connected communities. Scientific reports 9, 1 (2019),
1â€“12.

[81] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones,
Aidan N Gomez, Åukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you
need. Advances in neural information processing systems 30 (2017).

[82] Lewen Wang, Haozhe Zhao, Cunguang Feng, Weiqing Liu, Congrui Huang,
Marco Santoni, Manuel Cristofaro, Paola Jafrancesco, and Jiang Bian. 2023.
Removing camouflage and revealing collusion: Leveraging gang-crime pattern
in fraudster detection. In Proceedings of the 29th ACM SIGKDD conference on
knowledge discovery and data mining. 5104â€“5115.

[83] Shu Wang, Yixiang Fang, and Wensheng Luo. 2025. Searching and Detect-
ing Structurally Similar Communities in Large Heterogeneous Information
Networks. Proceedings of the VLDB Endowment 18, 5 (2025), 1425â€“1438.
[84] Xiao Wang, Nian Liu, Hui Han, and Chuan Shi. 2021. Self-supervised heteroge-
neous graph neural network with co-contrastive learning. In Proceedings of the
27th ACM SIGKDD conference on knowledge discovery & data mining. 1726â€“1736.
[85] Wei Xia, Qianqian Wang, Quanxue Gao, Xiangdong Zhang, and Xinbo Gao.
2021. Self-supervised graph convolutional network for multi-view clustering.
IEEE Transactions on Multimedia 24 (2021), 3182â€“3192.

[86] Jierui Xie, Mingming Chen, and Boleslaw K Szymanski. 2013. LabelrankT:
Incremental community detection in dynamic networks via label propagation.
In Proceedings of the workshop on dynamic networks management and mining.
25â€“32.

[87] Jierui Xie and Boleslaw K Szymanski. 2013. Labelrank: A stabilized label propa-
gation algorithm for community detection in networks. In 2013 IEEE 2nd Network
Science Workshop (NSW). IEEE, 138â€“143.

[88] Jierui Xie, Boleslaw K Szymanski, and Xiaoming Liu. 2011. Slpa: Uncovering
overlapping communities in social networks via a speaker-listener interaction
dynamic process. In 2011 ieee 11th international conference on data mining
workshops. IEEE, 344â€“349.

[89] Yu Xie, Maoguo Gong, Shanfeng Wang, and Bin Yu. 2018. Community discovery

in networks with deep sparse filtering. Pattern Recognition 81 (2018), 50â€“59.
[90] Lantian Xu, Dong Wen, Lu Qin, Ronghua Li, Ying Zhang, and Xuemin Lin. 2024.
Constant-time Connectivity Querying in Dynamic Graphs. Proceedings of the
ACM on Management of Data 2, 6 (2024), 1â€“23.

[91] Rongbin Xu, Yan Che, Xinmei Wang, Jianxiong Hu, and Ying Xie. 2020. Stacked
autoencoder-based community detection method via an ensemble clustering
framework. Information sciences 526 (2020), 151â€“165.

[92] Xiaowei Xu, Nurcan Yuruk, Zhidan Feng, and Thomas AJ Schweiger. 2007.
Scan: a structural clustering algorithm for networks. In Proceedings of the 13th
ACM SIGKDD international conference on Knowledge discovery and data mining.
824â€“833.

[93] Liang Yang, Xiaochun Cao, Dongxiao He, Chuan Wang, Xiao Wang, and Weix-
iong Zhang. 2016. Modularity based community detection with deep learning..
In IJCAI, Vol. 16. 2252â€“2258.

[94] Zhao Yang, RenÃ© Algesheimer, and Claudio J Tessone. 2016. A comparative
analysis of community detection algorithms on artificial networks. Scientific
reports 6, 1 (2016), 30750.

[95] Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William W Cohen, Ruslan
Salakhutdinov, and Christopher D Manning. 2018. HotpotQA: A dataset for di-
verse, explainable multi-hop question answering. arXiv preprint arXiv:1809.09600
(2018).

[96] Quanzeng You, Hailin Jin, Zhaowen Wang, Chen Fang, and Jiebo Luo. 2016.
Image captioning with semantic attention. In Proceedings of the IEEE conference
on computer vision and pattern recognition. 4651â€“4659.

[97] Neda Zarayeneh and Ananth Kalyanaraman. 2021. Delta-screening: a fast and
efficient technique to update communities in dynamic graphs. IEEE transactions
on network science and engineering 8, 2 (2021), 1614â€“1629.

[98] Fangyuan Zhang and Sibo Wang. 2022. Effective indexing for dynamic structural
graph clustering. Proceedings of the VLDB Endowment 15, 11 (2022), 2908â€“2920.
[99] Meng Zhang, Xingjie Pan, Won Jung, Aaron R Halpern, Stephen W Eichhorn,
Zhiyun Lei, Limor Cohen, Kimberly A Smith, Bosiljka Tasic, Zizhen Yao, et al.
2023. Molecularly defined and spatially resolved cell atlas of the whole mouse
brain. Nature 624, 7991 (2023), 343â€“354.

[100] Tianqi Zhang, Yun Xiong, Jiawei Zhang, Yao Zhang, Yizhu Jiao, and Yangyong
Zhu. 2020. CommDGI: community detection oriented deep graph infomax. In

Proceedings of the 29th ACM international conference on information & knowledge
management. 1843â€“1852.

[101] Xiaotong Zhang, Han Liu, Xiao-Ming Wu, Xianchao Zhang, and Xinyue Liu.
2021. Spectral embedding network for attributed graph clustering. Neural
Networks 142 (2021), 388â€“396.

[102] Yao Zhang, Yun Xiong, Yun Ye, Tengfei Liu, Weiqiang Wang, Yangyong Zhu,
and Philip S Yu. 2020. SEAL: Learning heuristics for community detection
with generative adversarial networks. In Proceedings of the 26th ACM SIGKDD
international conference on knowledge discovery & data mining. 1103â€“1113.
[103] Han Zhao, Xu Yang, Zhenru Wang, Erkun Yang, and Cheng Deng. 2021. Graph
debiased contrastive learning with joint representation clustering.. In IJCAI.
3434â€“3440.

[104] Yingli Zhou, Qingshuo Guo, Yi Yang, Yixiang Fang, Chenhao Ma, and Laks
In-depth Analysis of Densest Subgraph Discovery in a

Lakshmanan. 2024.
Unified Framework. arXiv preprint arXiv:2406.04738 (2024).

[105] Di Zhuang, J Morris Chang, and Mingchen Li. 2019. DynaMo: Dynamic com-
munity detection by incrementally maximizing modularity. IEEE Transactions
on Knowledge and Data Engineering 33, 5 (2019), 1934â€“1945.

Appendix
A Proof of lemmas
A.1 Proof of Lemma 2

Proof. We analyze the modularity gain Î”ğ‘€ (ğ‘£ â†’ âˆ…, ğ›¾) for any
vertex ğ‘£, which denotes the modularity gain of moving ğ‘£ from the
intermediate subsequence ğ¼ to âˆ…, whose calculation follows the
same formula as the standard modularity gain.

According to Definition 8, if Î”ğ‘€ (ğ‘£ â†’ âˆ…, ğ›¾) > 0, the intermediate
subsequence ğ¼ could not be ğ›¾-connected and ğ‘£ has to leave ğ¼ . It is
different from maintaining vertex optimality (mentioned in Defi-
nition 6): If there exists a community ğ¶ â€² such that the modularity
gain of moving ğ‘£ from its community ğ¶ to ğ¶ â€² is positive, ğ‘£ is not
locally optimized and has to be removed from ğ¶.

Case 1: ğ‘£ğ‘– is inserted into ğ‘† after ğ‘£ ğ‘— , i.e., ğ‘£ ğ‘— âˆˆ ğ¼ğ‘– . The old mod-

ularity gain ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) < 0 before deletion is:

ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
2ğ‘š

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘– ) Â· ğ‘‘ (ğ‘ˆğ‘– )
4ğ‘š2

â‰¤ 0.

(3)

Where ğ‘ˆğ‘– = ğ¼ğ‘– \ {ğ‘£ğ‘– }. We multiply right side of Equation (3) by

4ğ‘š2 and obtain ğ‘‹ (3) :

ğ‘‹ (3) = âˆ’2ğ‘š Â· ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) + ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘– ) Â· ğ‘‘ (ğ‘ˆğ‘– ) â‰¤ 0
After the deletion, the new modularity gain ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾)

(4)

formulates:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) âˆ’ 2ğ›¼
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) âˆ’ ğ›¼) Â· (ğ‘‘ (ğ‘ˆğ‘– ) âˆ’ ğ›¼)
4(ğ‘š âˆ’ ğ›¼)2

.

(5)

We multiply right side of Equation (5) by 4(ğ‘š âˆ’ ğ›¼)2 and obtain

ğ‘Œ(5) :

ğ‘Œ(5) = âˆ’2(ğ‘š âˆ’ ğ›¼) Â· (ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) âˆ’ 2ğ›¼)
+ ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) âˆ’ ğ›¼) Â· (ğ‘‘ (ğ‘ˆğ‘– ) âˆ’ ğ›¼)
= ğ‘‹ (3) + ğ›¼ Â· (4ğ‘š + 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) âˆ’ 4ğ‘ âˆ’ ğ›¾ Â· (ğ‘‘ (ğ¼ğ‘– ) âˆ’ ğ›¼))
< ğ‘‹ (3) + ğ›¼ Â· (4ğ‘š + 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ))

(6)

If ğ‘‹ (3) + ğ›¼ Â· (4ğ‘š + 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )) > 0, Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) could
be positive; Otherwise, Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) must be non-positive.
Therefore, ğ‘£ğ‘– could be removed from its sub-community only if
ğ›¼ > 2ğ‘šÂ·ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– ) âˆ’ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘– ) Â·ğ‘‘ (ğ‘ˆğ‘– )

.

4ğ‘š+2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

Case 2: ğ‘£ ğ‘— is inserted into ğ‘† before ğ‘£ğ‘– . In this case, we have
ğ‘£ ğ‘— âˆˆ ğ¼ ğ‘— , ğ‘£ğ‘– âˆ‰ ğ¼ ğ‘— , and the edge deletion does not affect intra-edges
within ğ‘ˆ ğ‘— . The old modularity gain ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) < 0 before
deletion is:

ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ ğ‘— â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— )
2ğ‘š

ğ›¾ Â· ğ‘‘ (ğ‘£ ğ‘— ) Â· ğ‘‘ (ğ‘ˆ ğ‘— )
4ğ‘š2

.

+

(7)

We multiply right side of Equation (3) by 4ğ‘š2 and obtain ğ‘‹ (3) :
(8)
ğ‘‹ (7) = âˆ’2ğ‘š Â· ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— ) + ğ›¾ Â· ğ‘‘ (ğ‘£ ğ‘— ) Â· ğ‘‘ (ğ‘ˆ ğ‘— ) < 0
The new modularity gain after the edge deletion becomes:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ ğ‘— â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— )
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· (ğ‘‘ (ğ‘£ ğ‘— ) âˆ’ ğ›¼) Â· ğ‘‘ (ğ‘ˆ ğ‘— )
4(ğ‘š âˆ’ ğ›¼)2

(9)

We multiply right side of Equation (9) by 4(ğ‘š âˆ’ ğ›¼)2 and obtain

ğ‘Œ(9) :

(3) ğ‘£ğ‘˜ is merged after ğ‘£ğ‘– and ğ‘£ ğ‘— :
ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š âˆ’ ğ›¼)

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) = âˆ’

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· (ğ‘‘ (ğ‘ˆğ‘˜ ) âˆ’ 2ğ›¼)
4(ğ‘š âˆ’ ğ›¼)2

. (19)

Therefore, the equivalent of Equation (15) holds if and only if ğ‘£ğ‘˜
is merged before ğ‘£ğ‘– and ğ‘£ ğ‘— . Then, We multiply right side of Equation
(15) and (16) by 4(ğ‘š âˆ’ ğ›¼)2 respectively and obtain ğ‘Œ(15) and ğ‘Œ(16) :

ğ‘Œ(15) = âˆ’2(ğ‘š âˆ’ ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
+ ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ )
= ğ‘‹13 + 2ğ›¼ Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ ),

ğ‘Œ(16) = ğ‘‹14 + 2ğ›¼ Â· ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ ),
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ ) Â·ğ‘‘ (ğ‘ˆğ‘˜ )
2ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )

Only if ğ›¼ > ğ‘š âˆ’

, ğ‘£ğ‘˜ could be removed from its sub-
community; ğ‘£ğ‘™ should be removed from its sub-community if and
only if ğ›¼ > ğ‘š âˆ’

.

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘™ ) Â·ğ‘‘ (ğ‘ˆğ‘™ )
2ğ‘¤ (ğ‘£ğ‘™ ,ğ‘ˆğ‘™ )

ğ‘Œ(9) = âˆ’2(ğ‘š âˆ’ ğ›¼) Â· ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— ) + ğ›¾ Â· (ğ‘‘ (ğ‘£ ğ‘— ) âˆ’ ğ›¼) Â· ğ‘‘ (ğ‘ˆ ğ‘— )

A.2 Proof of Lemma 3

= ğ‘‹ (7) + 2ğ›¼ Â· (ï¸ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— ) âˆ’ ğ›¾ Â· ğ‘‘ (ğ‘ˆ ğ‘— ))ï¸
< ğ‘‹ (7) + 2ğ›¼ Â· ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— )

(10)

Hence, ğ‘£ ğ‘— could be removed from its sub-community only if

Proof. We adopt the same notations as in the proof of Lemma
2, with the exception that ğ‘£ğ‘˜ now denotes a vertex residing in the
same sub-community as either ğ‘£ğ‘– or ğ‘£ ğ‘— . Based on this setup, the
modularity gain after the edge deletion is shown as follows.

ğ›¼ > ğ‘š âˆ’

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘— ) Â·ğ‘‘ (ğ‘ˆ ğ‘— )
2ğ‘¤ (ğ‘£ğ‘— .ğ‘ˆ ğ‘— )

.

Generalization to other vertices. Consider other vertices ğ‘£ğ‘˜
and ğ‘£ğ‘™ such that ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– , ğ‘˜ â‰  ğ‘–, ğ‘— and ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– . The old modularity
gains ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) < 0 and ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘™ â†’ âˆ…, ğ›¾) < 0 before deletion
are:

ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2ğ‘š

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ )
4ğ‘š2

.

ğ‘€ğ‘œğ‘™ğ‘‘ (ğ‘£ğ‘™ â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
2ğ‘š

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
4ğ‘š2

.

(11)

(12)

We multiply right side of Equation (11) and (12) by 4ğ‘š2 respec-

tively to obtain ğ‘‹ (11) and ğ‘‹ (12) :

ğ‘‹ (11) = âˆ’2ğ‘š Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ ) + ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ ) â‰¤ 0

(13)

(14)
ğ‘‹ (12) = âˆ’2ğ‘š Â· ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ ) + ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ ) â‰¤ 0
After the edge deletion, their new modularity gains are satisfied:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) â‰¤ âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ )
4(ğ‘š âˆ’ ğ›¼)2

.

(15)

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘™ â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
2(ğ‘š âˆ’ ğ›¼)
ğ‘£ğ‘˜ could be merged before ğ‘£ğ‘– and ğ‘£ ğ‘— , between ğ‘£ğ‘– and ğ‘£ ğ‘— , as well
as after ğ‘£ğ‘– and ğ‘£ ğ‘— . Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) can be formulated as follows:

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
4(ğ‘š âˆ’ ğ›¼)2

(16)

+

.

(1) ğ‘£ğ‘˜ is merged before ğ‘£ğ‘– and ğ‘£ ğ‘— :

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š âˆ’ ğ›¼)
(2)ğ‘£ğ‘˜ is merged between ğ‘£ğ‘– and ğ‘£ ğ‘— :

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ )
4(ğ‘š âˆ’ ğ›¼)2

;

(17)

Case 1: Consider the endpoint ğ‘£ğ‘– :

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) âˆ’ ğ›¼) Â· ğ‘‘ (ğ‘ˆğ‘– )
4(ğ‘š âˆ’ ğ›¼)2

.

(22)

We multiply right side of Equation (22) by 4(ğ‘š âˆ’ ğ›¼)2 and obtain

ğ‘Œ(22) :

ğ‘Œ(22) = âˆ’2(ğ‘š âˆ’ ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
+ ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) âˆ’ ğ›¼) Â· ğ‘‘ (ğ‘ˆğ‘– )
= ğ‘‹ (3) + ğ›¼ Â· (2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) âˆ’ ğ›¾ Â· ğ‘‘ (ğ‘ˆğ‘– ))
< ğ‘‹ (3) + ğ›¼ Â· 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘– ) Â·ğ‘‘ (ğ‘ˆğ‘– )
2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )

Only if ğ›¼ > ğ‘š âˆ’

, ğ‘£ğ‘– could be removed from its sub-

community. ğ‘£ ğ‘— holds similar behavior.

Case 2: Consider the vertex ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– âˆª ğ‘† ğ‘— , ğ‘˜ â‰  ğ‘–, ğ‘—:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) â‰¤ âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ )
4(ğ‘š âˆ’ ğ›¼)2

.

(24)

For Equation (24), ğ‘£ğ‘˜ could be merged before ğ‘£ğ‘– or ğ‘£ ğ‘— , as well as
after ğ‘£ğ‘– or ğ‘£ ğ‘— . Its equivalent holds if and only if ğ‘£ğ‘˜ is merged before
ğ‘£ğ‘– or ğ‘£ ğ‘— . We multiply right side of Equation (24) by 4(ğ‘š âˆ’ ğ›¼)2 and
obtain ğ‘Œ(24) :

ğ‘Œ(24) = âˆ’2(ğ‘š âˆ’ ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ ) + ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· ğ‘‘ (ğ‘ˆğ‘˜ )

(25)

= ğ‘‹ (11) + 2ğ›¼ Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ ) Â·ğ‘‘ (ğ‘ˆğ‘˜ )
2ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )

Only if ğ›¼ > ğ‘š âˆ’

sub-community.

Case 3: Consider the vertex ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– âˆª ğ‘† ğ‘— :

, ğ‘£ğ‘˜ could be removed from its

(20)

(21)

â–¡

(23)

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· (ğ‘‘ (ğ‘ˆğ‘˜ ) âˆ’ ğ›¼)
4(ğ‘š âˆ’ ğ›¼)2

;

(18)

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘™ â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
2(ğ‘š âˆ’ ğ›¼)

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
4(ğ‘š âˆ’ ğ›¼)2

.

(26)

Efficient Maintenance of Leiden Communities in Large Dynamic Graphs

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Similar to Case 2, if and only if ğ›¼ > ğ‘š âˆ’

be removed from its sub-community.

ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘™ ) Â·ğ‘‘ (ğ‘ˆğ‘™ )
2ğ‘¤ (ğ‘£ğ‘™ ,ğ‘ˆğ‘™ )

, ğ‘£ğ‘™ should

Only if ğ›¼ > ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ )

sub-community.

Â· ğ‘š âˆ’ 1

2ğ‘‘ (ğ‘ˆğ‘˜ ), ğ‘£ğ‘˜ could be removed from its

â–¡

Case 4: Consider other vertex ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– :

(28)

Case 5: Consider the endpoint ğ‘£ğ‘– :

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
2(ğ‘š + ğ›¼)

A.3 Proof of Lemma 4

Proof. First, we analyze the insertion of intra-sub-community
edges. We adopt the same notations as in the proof of Lemma 2.
Based on this setup, the modularity gain after the edge insertion is
shown as follows.

Case 1: Consider the endpoint ğ‘£ğ‘– , which is the latter merged

endpoint:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘– â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) + 2ğ›¼
2(ğ‘š + ğ›¼)

+

ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) + ğ›¼) Â· (ğ‘‘ (ğ‘ˆğ‘– ) + ğ›¼)
4(ğ‘š + ğ›¼)2

.

(27)

We multiply right side of Equation (27) by 4(ğ‘š + ğ›¼)2 and obtain

ğ‘Œ(27) :

ğ‘Œ(27) = âˆ’2(ğ‘š + ğ›¼)(ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) + 2ğ›¼)
+ ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) + ğ›¼) Â· (ğ‘‘ (ğ‘ˆğ‘– ) + ğ›¼)
= ğ‘‹ (3) + ğ›¼ Â· (ï¸ğ›¾ Â· (ğ‘‘ (ğ¼ğ‘– ) + ğ›¼) âˆ’ 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ) âˆ’ 4ğ›¼ âˆ’ 4ğ‘š)ï¸
< ğ‘‹ (3) + ğ›¼ Â· (ï¸ğ›¾ Â· (ğ‘‘ (ğ¼ğ‘– ) + ğ›¼) âˆ’ 4ğ‘š)ï¸

Obviously, only if ğ›¾ Â· (ğ‘‘ (ğ¼ğ‘– ) + ğ›¼) âˆ’ 4ğ‘š > 0, i.e., ğ›¼ > 4

ğ›¾ ğ‘š âˆ’ ğ‘‘ (ğ¼ğ‘– ),

ğ‘Œ(27) could be positive.

endpoint:

Case 2: Consider the endpoint ğ‘£ ğ‘— , which is the former merged

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ ğ‘— â†’ âˆ…, ğ›¾) = âˆ’

ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆğ‘– )
2(ğ‘š + ğ›¼)

+

ğ›¾ Â· (ğ‘‘ (ğ‘£ ğ‘— ) + ğ›¼) Â· ğ‘‘ (ğ‘ˆğ‘– )
4(ğ‘š + ğ›¼)2

.

ğ‘Œ(35) :

(29)

We multiply right side of Equation (29) by 4(ğ‘š + ğ›¼)2 and obtain

ğ‘Œ(29) :

ğ‘Œ(29) = âˆ’2(ğ‘š + ğ›¼) Â· ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— )
+ ğ›¾ Â· (ğ‘‘ (ğ‘£ ğ‘— ) + ğ›¼) Â· ğ‘‘ (ğ‘ˆ ğ‘— )
= ğ‘‹ (7) + ğ›¼ Â· (ğ›¾ Â· ğ‘‘ (ğ‘ˆ ğ‘— ) âˆ’ ğ‘¤ (ğ‘£ ğ‘—, ğ‘ˆ ğ‘— ))
< ğ‘‹ (7) + ğ›¼ Â· ğ›¾ Â· ğ‘‘ (ğ‘ˆ ğ‘— )

(30)

Only if ğ›¼ > 2ğ‘¤ (ğ‘£ğ‘— ,ğ‘ˆ ğ‘— )
ğ›¾ Â·ğ‘‘ (ğ‘ˆ ğ‘— )

sub-community.

Â· ğ‘š âˆ’ ğ‘‘ (ğ‘£ ğ‘— ), ğ‘£ ğ‘— could be removed from its

Case 3: Consider other vertex ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– , ğ‘˜ â‰  ğ‘–, ğ‘—:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) â‰¤ âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š + ğ›¼)

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· (ğ‘‘ (ğ‘ˆğ‘˜ ) + 2ğ›¼)
4(ğ‘š + ğ›¼)2

.

(31)

The equivalent of Equation (31) holds if and only if ğ‘£ğ‘˜ is merged
after ğ‘£ğ‘– and ğ‘£ ğ‘— . We multiply right side of Equation (31) by 4(ğ‘š + ğ›¼)2
and obtain ğ‘Œ(31) :

ğ‘Œ(31) = âˆ’2(ğ‘š + ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
+ ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· (ğ‘‘ (ğ‘ˆğ‘˜ ) + 2ğ›¼)
= ğ‘‹ (11) + ğ›¼ Â· (ï¸2ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) âˆ’ 2ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ ))ï¸
< ğ‘‹ (11) + 2ğ›¼ Â· ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ )

(32)

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘™ â†’ âˆ…, ğ›¾) â‰¤ âˆ’

ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
2(ğ‘š + ğ›¼)
ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
4(ğ‘š + ğ›¼)2

+

(33)

.

Equation (33) holds if and only if ğ‘£ ğ‘— is merged after ğ‘£ğ‘– and ğ‘£ ğ‘— . We
multiply right side of Equation (33) by 4(ğ‘š + ğ›¼)2 and obtain ğ‘Œ(31) :

ğ‘Œ(33) = âˆ’2(ğ‘š + ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
+ ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
= ğ‘‹ (12) âˆ’ 2ğ›¼ Â· ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ ) < 0

(34)

ğ‘£ğ‘™ is not affected by the intra-sub-community insertion.

Now, we consider the insertion of cross-sub-community
edges. We adopt the same notations as in the proof of Lemma
3. Based on this setup, the modularity gain after the edge insertion
is shown as follows.

+

ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) + ğ›¼) Â· ğ‘‘ (ğ‘ˆğ‘– )
4(ğ‘š + ğ›¼)2

.

(35)

We multiply right side of Equation (35) by 4(ğ‘š + ğ›¼)2 and obtain

ğ‘Œ(35) = âˆ’2(ğ‘š + ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
+ ğ›¾ Â· (ğ‘‘ (ğ‘£ğ‘– ) + ğ›¼) Â· ğ‘‘ (ğ‘ˆğ‘– )
= ğ‘‹ (3) + ğ›¼ Â· (ï¸ğ›¾ Â· ğ‘‘ (ğ‘ˆğ‘– ) âˆ’ 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ))ï¸
< ğ‘‹ (3) + ğ›¼ Â· ğ›¾ Â· ğ‘‘ (ğ‘ˆğ‘– )

(36)

Only if ğ›¼ > 2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )
ğ›¾ Â·ğ‘‘ (ğ‘ˆğ‘– )
sub-community. ğ‘£ ğ‘— is the same.

Â· ğ‘š âˆ’ ğ‘‘ (ğ‘£ğ‘– ), ğ‘£ğ‘– could be removed from its

Case 6: Consider other vertex ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– âˆª ğ‘† ğ‘— , ğ‘˜ â‰  ğ‘–, ğ‘—:

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘˜ â†’ âˆ…, ğ›¾) â‰¤ âˆ’

ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘˜ )
2(ğ‘š + ğ›¼)

+

ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘˜ ) Â· (ğ‘‘ (ğ‘ˆğ‘˜ ) + ğ›¼)
4(ğ‘š + ğ›¼)2

.

(37)

The equivalent of Equation (37) holds if and only if ğ‘£ğ‘˜ is merged
after ğ‘£ğ‘– or ğ‘£ ğ‘— . We multiply right side of Equation (37) by 4(ğ‘š + ğ›¼)2
and obtain ğ‘Œ(37) :

ğ‘Œ(37) = âˆ’2(ğ‘š + ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– )
+ ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘– ) Â· (ğ‘‘ (ğ‘ˆğ‘– ) + ğ›¼)
= ğ‘‹ (3) + ğ›¼ Â· (ï¸ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘– ) âˆ’ 2ğ‘¤ (ğ‘£ğ‘–, ğ‘ˆğ‘– ))ï¸
< ğ‘‹ (3) + ğ›¼ Â· ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘– )
< ğ‘‹ (3) + 2ğ›¼ Â· ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘– )

(38)

ğ‘£ğ‘˜ could be removed from its sub-community only if ğ›¼ > ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )
ğ›¾ğ‘‘ (ğ‘£ğ‘˜ )

Â·

ğ‘š âˆ’ 1

2ğ‘‘ (ğ‘ˆğ‘˜ ).

Case 7: Consider other vertex ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– :

SIGMOD â€™26, May 03â€“June 05, 2026, Bengaluru, India

Lin et al.

)
s

m

(

e
m

i
t
n
u
R

0.8

0.75

0.7

0.65

0.5

8

2

ğ›¾
(a) DC

32

0.4

0.3

0.2

0.1

0

ST-Leiden

ND-Leiden
0.5

DS-Leiden

DF-Leiden

HIT-Leiden

0.4

0.3

0.2

0.1

0.5

2

8

32

ğ›¾
(b) YS

0.5

2

8

32

ğ›¾
(c) SS
Figure 19: Runtime w.r.t. ğ›¾.

1

0.98

0.96

0.4
0.38
0.36
0.34
0.32
0.3

0.5

8

2

ğ›¾
(e) RS

32

0.5

8

2

ğ›¾
(d) IT

32

Î”ğ‘€ğ‘›ğ‘’ğ‘¤ (ğ‘£ğ‘™ â†’ âˆ…, ğ›¾) â‰¤ âˆ’

ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
2(ğ‘š + ğ›¼)
ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
4(ğ‘š + ğ›¼)2

+

(39)

.

Equation (39) holds if and only if ğ‘£ ğ‘— is merged after ğ‘£ğ‘– and ğ‘£ ğ‘— . We
multiply right side of Equation (39) by 4(ğ‘š + ğ›¼)2 and obtain ğ‘Œ(37) :

ğ‘Œ(39) = âˆ’2(ğ‘š + ğ›¼) Â· ğ‘¤ (ğ‘£ğ‘™, ğ‘ˆğ‘™ )
+ ğ›¾ Â· ğ‘‘ (ğ‘£ğ‘™ ) Â· ğ‘‘ (ğ‘ˆğ‘™ )
= ğ‘‹ (12) âˆ’ 2ğ›¼ Â· ğ‘¤ (ğ‘£ğ‘˜, ğ‘ˆğ‘™ ) < 0

(40)

ğ‘£ğ‘™ is not affected by the cross-sub-community insertion.
Conclusively, the effects of these edge insertions are:
(1) ğ‘£ğ‘– could be removed from its sub-community only if ğ›¼ >
Â· ğ‘š âˆ’ ğ‘‘ (ğ‘£ğ‘– ) according to Case 1

4

ğ›¾ ğ‘š âˆ’ ğ‘‘ (ğ¼ğ‘– ) or ğ›¼ > 2ğ‘¤ (ğ‘£ğ‘– ,ğ‘ˆğ‘– )
ğ›¾ Â·ğ‘‘ (ğ‘ˆğ‘– )
and 5.

2ğ‘¤ (ğ‘£ğ‘— ,ğ‘ˆ ğ‘— )
ğ›¾ Â·ğ‘‘ (ğ‘ˆ ğ‘— )

(2) ğ‘£ ğ‘— could be removed from its sub-community, only if ğ›¼ >
Â· ğ‘š âˆ’ ğ‘‘ (ğ‘£ ğ‘— ) according to Case 2 and 5.
(3) ğ‘£ğ‘˜ âˆˆ ğ‘†ğ‘– âˆª ğ‘† ğ‘— (ğ‘˜ â‰  ğ‘–, ğ‘—) could be removed from its sub-
2ğ‘‘ (ğ‘ˆğ‘˜ ) according

community only if ğ›¼ > ğ‘¤ (ğ‘£ğ‘˜ ,ğ‘ˆğ‘˜ )
ğ›¾ Â·ğ‘‘ (ğ‘£ğ‘˜ )
to Case 3 and 6.

Â· ğ‘š âˆ’ 1

(4) ğ‘£ğ‘™ âˆ‰ ğ‘†ğ‘– âˆª ğ‘† ğ‘— is unaffected according to Case 4 and 7.

â–¡

B Inaddtional experiments
â€¢ Effect of ğ›¾ on modularity. Figure 19 shows the average modu-
larity values for all maintenance algorithms, with the parameter
ğ›¾ âˆˆ {0.5, 2, 8, 32} across all 9 batches, and with the batch size fixed
at 1000. Across all datasets, these maintenance algorithms achieve
equivalent quality in modularity, since the difference in their mod-
ularity values is within 0.01. Overall, our HIT-Leiden still achieves
comparable modularity with other methods across different ğ›¾.


